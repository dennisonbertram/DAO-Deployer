{"success":true,"status":"completed","completed":20,"total":20,"creditsUsed":20,"expiresAt":"2025-08-22T13:40:25.000Z","data":[{"markdown":"# Contracts\n\n**A library for secure smart contract development.** Build on a solid foundation of community-vetted code.\n\n- Implementations of standards like [ERC20](https://docs.openzeppelin.com/contracts/5.x/erc20) and [ERC721](https://docs.openzeppelin.com/contracts/5.x/erc721).\n\n- Flexible [role-based permissioning](https://docs.openzeppelin.com/contracts/5.x/access-control) scheme.\n\n- Reusable [Solidity components](https://docs.openzeppelin.com/contracts/5.x/utilities) to build custom contracts and complex decentralized systems.\n\n\n|     |     |\n| --- | --- |\n|  | OpenZeppelin Contracts uses semantic versioning to communicate backwards compatibility of its API and storage layout. For upgradeable contracts, the storage layout of different major versions should be assumed incompatible, for example, it is unsafe to upgrade from 4.9.3 to 5.0.0. Learn more at [Backwards Compatibility](https://docs.openzeppelin.com/contracts/5.x/backwards-compatibility). |\n\n## Overview\n\n### Installation\n\n#### Hardhat (npm)\n\n```console hljs language-shell\n$ npm install @openzeppelin/contracts\n```\n\n#### Foundry (git)\n\n|     |     |\n| --- | --- |\n|  | When installing via git, it is a common error to use the `master` branch. This is a development branch that should be avoided in favor of tagged releases. The release process involves security measures that the `master` branch does not guarantee. |\n\n|     |     |\n| --- | --- |\n|  | Foundry installs the latest version initially, but subsequent `forge update` commands will use the `master` branch. |\n\n```console hljs language-shell\n$ forge install OpenZeppelin/openzeppelin-contracts\n```\n\nAdd `@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/` in `remappings.txt.`\n\n### Usage\n\nOnce installed, you can use the contracts in the library by importing them:\n\n```solidity hljs\n// contracts/MyNFT.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MyNFT is ERC721 {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n}\n```\n\n|     |     |\n| --- | --- |\n|  | If you‚Äôre new to smart contract development, head to [Developing Smart Contracts](https://docs.openzeppelin.com/learn/developing-smart-contracts) to learn about creating a new project and compiling your contracts. |\n\nTo keep your system secure, you should **always** use the installed code as-is, and neither copy-paste it from online sources, nor modify it yourself. The library is designed so that only the contracts and functions you use are deployed, so you don‚Äôt need to worry about it needlessly increasing gas costs.\n\n## Security\n\nPlease report any security issues you find via our [bug bounty program on Immunefi](https://www.immunefi.com/bounty/openzeppelin) or directly to [security@openzeppelin.org](mailto:security@openzeppelin.org).\n\nThe [Security Center](https://contracts.openzeppelin.com/security) contains more details about the secure development process.\n\n## Learn More\n\nThe guides in the sidebar will teach about different concepts, and how to use the related contracts that OpenZeppelin Contracts provides:\n\n- [Access Control](https://docs.openzeppelin.com/contracts/5.x/access-control): decide who can perform each of the actions on your system.\n\n- [Tokens](https://docs.openzeppelin.com/contracts/5.x/tokens): create tradable assets or collectibles, like the well known [ERC20](https://docs.openzeppelin.com/contracts/5.x/erc20) and [ERC721](https://docs.openzeppelin.com/contracts/5.x/erc721) standards.\n\n- [Utilities](https://docs.openzeppelin.com/contracts/5.x/utilities): generic useful tools, including non-overflowing math, signature verification, and trustless paying systems.\n\n\nThe [full API](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20) is also thoroughly documented, and serves as a great reference when developing your smart contract application. You can also ask for help or follow Contracts' development in the [community forum](https://forum.openzeppelin.com/).\n\nThe following articles provide great background reading, though please note, some of the referenced tools have changed as the tooling in the ecosystem continues to rapidly evolve.\n\n- [The Hitchhiker‚Äôs Guide to Smart Contracts in Ethereum](https://blog.openzeppelin.com/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05) will help you get an overview of the various tools available for smart contract development, and help you set up your environment.\n\n- [A Gentle Introduction to Ethereum Programming, Part 1](https://blog.openzeppelin.com/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094) provides very useful information on an introductory level, including many basic concepts from the Ethereum platform.\n\n- For a more in-depth dive, you may read the guide [Designing the architecture for your Ethereum application](https://blog.openzeppelin.com/designing-the-architecture-for-your-ethereum-application-9cec086f8317), which discusses how to better structure your application and its relationship to the real world.\n\n\n[Wizard ‚Üí](https://docs.openzeppelin.com/contracts/5.x/wizard)","metadata":{"language":"en","viewport":"width=device-width, initial-scale=1.0","ogImage":"https://docs.openzeppelin.com/_/images/social.png","ogTitle":"Contracts - OpenZeppelin Docs","og:title":"Contracts - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","og:image":"https://docs.openzeppelin.com/_/images/social.png","twitter:card":"summary","title":"Contracts - OpenZeppelin Docs","scrapeId":"080cebed-2884-4f13-b0cc-c13c6bef85bd","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/","url":"https://docs.openzeppelin.com/contracts/5.x/","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1}},{"markdown":"# Utilities\n\nThe OpenZeppelin Contracts provide a ton of useful utilities that you can use in your project. For a complete list, check out the [API Reference](https://docs.openzeppelin.com/contracts/5.x/api/utils).\nHere are some of the more popular ones.\n\n## Cryptography\n\n### Checking Signatures On-Chain\n\nAt a high level, signatures are a set of cryptographic algorithms that allow for a _signer_ to prove himself owner of a _private key_ used to authorize a piece of information (generally a transaction or `UserOperation`). Natively, the EVM supports the Elliptic Curve Digital Signature Algorithm ( [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) using the secp256k1 curve, however other signature algorithms such as P256 and RSA are supported.\n\n#### Ethereum Signatures (secp256k1)\n\n[`ECDSA`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#ECDSA) provides functions for recovering and managing Ethereum account ECDSA signatures. These are often generated via [`web3.eth.sign`](https://web3js.readthedocs.io/en/v1.7.3/web3-eth.html#sign), and form a 65-byte array (of type `bytes` in Solidity) arranged the following way: `[[v (1)], [r (32)], [s (32)]]`.\n\nThe data signer can be recovered with [`ECDSA.recover`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#ECDSA-recover-bytes32-bytes-), and its address compared to verify the signature. Most wallets will hash the data to sign and add the prefix `\\x19Ethereum Signed Message:\\n`, so when attempting to recover the signer of an Ethereum signed message hash, you‚Äôll want to use [`toEthSignedMessageHash`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MessageHashUtils-toEthSignedMessageHash-bytes32-).\n\n```solidity hljs\nusing ECDSA for bytes32;\nusing MessageHashUtils for bytes32;\n\nfunction _verify(bytes32 data, bytes memory signature, address account) internal pure returns (bool) {\n    return data\n        .toEthSignedMessageHash()\n        .recover(signature) == account;\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Getting signature verification right is not trivial: make sure you fully read and understand [`MessageHashUtils`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MessageHashUtils)'s and [`ECDSA`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#ECDSA)'s documentation. |\n\n#### P256 Signatures (secp256r1)\n\nP256, also known as secp256r1, is one of the most used signature schemes. P256 signatures are standardized by the National Institute of Standards and Technology (NIST) and they are widely available in consumer hardware and software.\n\nThese signatures are different from regular Ethereum Signatures (secp256k1) in that they use a different elliptic curve to perform operations but have similar security guarantees.\n\n```solidity hljs\nusing P256 for bytes32;\n\nfunction _verify(\n    bytes32 data,\n    bytes32 r,\n    bytes32 s,\n    bytes32 qx,\n    bytes32 qy\n) internal pure returns (bool) {\n    return data.verify(data, r, s, qx, qy);\n}\n```\n\nBy default, the `verify` function will try calling the [RIP-7212](https://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md) precompile at address `0x100` and will fallback to an implementation in Solidity if not available. We encourage you to use `verifyNative` if you know the precompile is available on the chain you‚Äôre working on and on any other chain on which you intend to use the same bytecode in the future. In case of any doubts regarding the implementation roadmap of the native precompile `P256` of potential future target chains, please consider using `verifySolidity`.\n\n```solidity hljs\nusing P256 for bytes32;\n\nfunction _verify(\n    bytes32 data,\n    bytes32 r,\n    bytes32 s,\n    bytes32 qx,\n    bytes32 qy\n) internal pure returns (bool) {\n    // Will only call the precompile at address(0x100)\n    return data.verifyNative(data, r, s, qx, qy);\n}\n```\n\n|     |     |\n| --- | --- |\n|  | The P256 library only allows for `s` values in the lower order of the curve (i.e. `s ‚áê N/2`) to prevent malleability. In case your tooling produces signatures in both sides of the curve, consider flipping the `s` value to keep compatibility. |\n\n#### RSA\n\nRSA is a public-key cryptosystem that was popularized by corporate and governmental public key infrastructures ( [PKIs](https://en.wikipedia.org/wiki/Public_key_infrastructure)) and [DNSSEC](https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions).\n\nThis cryptosystem consists of using a private key that‚Äôs the product of 2 large prime numbers. The message is signed by applying a modular exponentiation to its hash (commonly SHA256), where both the exponent and modulus compose the public key of the signer.\n\nRSA signatures are known for being less efficient than elliptic curve signatures given the size of the keys, which are big compared to ECDSA keys with the same security level. Using plain RSA is considered unsafe, this is why the implementation uses the `EMSA-PKCS1-v1_5` encoding method from [RFC8017](https://datatracker.ietf.org/doc/html/rfc8017) to include padding to the signature.\n\nTo verify a signature using RSA, you can leverage the [`RSA`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#RSA) library that exposes a method for verifying RSA with the PKCS 1.5 standard:\n\n```solidity hljs\nusing RSA for bytes32;\n\nfunction _verify(\n    bytes32 data,\n    bytes memory signature,\n    bytes memory e,\n    bytes memory n\n) internal pure returns (bool) {\n    return data.pkcs1Sha256(signature, e, n);\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Always use keys of at least 2048 bits. Additionally, be aware that PKCS#1 v1.5 allows for replayability due to the possibility of arbitrary optional parameters. To prevent replay attacks, consider including an onchain nonce or unique identifier in the message. |\n\n### Signature Verification\n\nThe [`SignatureChecker`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignatureChecker) library provides a unified interface for verifying signatures from different sources. It seamlessly supports:\n\n- ECDSA signatures from externally owned accounts (EOAs)\n\n- ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet\n\n- ERC-7913 signatures from keys that don‚Äôt have their own Ethereum address\n\n\nThis allows developers to write signature verification code once and have it work across all these different signature types.\n\n#### Basic Signature Verification\n\nFor standard signature verification that supports both EOAs and ERC-1271 contracts:\n\n```solidity hljs\nusing SignatureChecker for address;\n\nfunction _verifySignature(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n    return SignatureChecker.isValidSignatureNow(signer, hash, signature);\n}\n```\n\nThe library automatically detects whether the signer is an EOA or a contract and uses the appropriate verification method.\n\n#### ERC-1271 Contract Signatures\n\nFor smart contract wallets that implement ERC-1271, you can explicitly use:\n\n```solidity hljs\nfunction _verifyContractSignature(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n    return SignatureChecker.isValidERC1271SignatureNow(signer, hash, signature);\n}\n```\n\n#### ERC-7913 Extended Signatures\n\nERC-7913 extends signature verification to support keys that don‚Äôt have their own Ethereum address. This is useful for integrating non-Ethereum cryptographic curves, hardware devices, or other identity systems.\n\nA signer is represented as a `bytes` object that concatenates a verifier address and a key: `verifier || key`.\n\n```solidity hljs\nfunction _verifyERC7913Signature(bytes memory signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n    return SignatureChecker.isValidSignatureNow(signer, hash, signature);\n}\n```\n\nThe verification process works as follows:\n\n- If `signer.length < 20`: verification fails\n\n- If `signer.length == 20`: verification is done using standard signature checking\n\n- Otherwise: verification is done using an ERC-7913 verifier\n\n\n#### Batch Verification\n\nFor verifying multiple ERC-7913 signatures at once:\n\n```solidity hljs\nfunction _verifyMultipleSignatures(\n    bytes32 hash,\n    bytes[] memory signers,\n    bytes[] memory signatures\n) internal view returns (bool) {\n    return SignatureChecker.areValidSignaturesNow(hash, signers, signatures);\n}\n```\n\nThis function will reject inputs that contain duplicated signers. Sorting the signers by their `keccak256` hash is recommended to minimize the gas cost.\n\nThis unified approach allows smart contracts to accept signatures from any supported source without needing to implement different verification logic for each type.\n\n### Verifying Merkle Proofs\n\nDevelopers can build a Merkle Tree off-chain, which allows for verifying that an element (leaf) is part of a set by using a Merkle Proof. This technique is widely used for creating whitelists (e.g., for airdrops) and other advanced use cases.\n\n|     |     |\n| --- | --- |\n|  | OpenZeppelin Contracts provides a [JavaScript library](https://github.com/OpenZeppelin/merkle-tree) for building trees off-chain and generating proofs. |\n\n[`MerkleProof`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MerkleProof) provides:\n\n- [`verify`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MerkleProof-verify-bytes32---bytes32-bytes32-) \\- can prove that some value is part of a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree).\n\n- [`multiProofVerify`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MerkleProof-multiProofVerify-bytes32-bytes32---bytes32---bool---) \\- can prove multiple values are part of a Merkle tree.\n\n\nFor an on-chain Merkle Tree, see the [`MerkleTree`](https://docs.openzeppelin.com/contracts/5.x/api/utils#MerkleTree) library.\n\n## Introspection\n\nIn Solidity, it‚Äôs frequently helpful to know whether or not a contract supports an interface you‚Äôd like to use. ERC-165 is a standard that helps do runtime interface detection. Contracts provide helpers both for implementing ERC-165 in your contracts and querying other contracts:\n\n- [`IERC165`](https://docs.openzeppelin.com/contracts/5.x/api/utils#IERC165) ‚Äî this is the ERC-165 interface that defines [`supportsInterface`](https://docs.openzeppelin.com/contracts/5.x/api/utils#IERC165-supportsInterface-bytes4-). When implementing ERC-165, you‚Äôll conform to this interface.\n\n- [`ERC165`](https://docs.openzeppelin.com/contracts/5.x/api/utils#ERC165) ‚Äî inherit this contract if you‚Äôd like to support interface detection using a lookup table in contract storage. You can register interfaces using [`_registerInterface(bytes4)`](https://docs.openzeppelin.com/contracts/5.x/api/utils#ERC165-_registerInterface-bytes4-): check out example usage as part of the ERC-721 implementation.\n\n- [`ERC165Checker`](https://docs.openzeppelin.com/contracts/5.x/api/utils#ERC165Checker) ‚Äî ERC165Checker simplifies the process of checking whether or not a contract supports an interface you care about.\n\n- include with `using ERC165Checker for address;`\n\n- [`myAddress._supportsInterface(bytes4)`](https://docs.openzeppelin.com/contracts/5.x/api/utils#ERC165Checker-_supportsInterface-address-bytes4-)\n\n- [`myAddress._supportsAllInterfaces(bytes4[])`](https://docs.openzeppelin.com/contracts/5.x/api/utils#ERC165Checker-_supportsAllInterfaces-address-bytes4---)\n\n\n```solidity hljs\ncontract MyContract {\n    using ERC165Checker for address;\n\n    bytes4 private InterfaceId_ERC721 = 0x80ac58cd;\n\n    /**\n     * @dev transfer an ERC-721 token from this contract to someone else\n     */\n    function transferERC721(\n        address token,\n        address to,\n        uint256 tokenId\n    )\n        public\n    {\n        require(token.supportsInterface(InterfaceId_ERC721), \"IS_NOT_721_TOKEN\");\n        IERC721(token).transferFrom(address(this), to, tokenId);\n    }\n}\n```\n\n## Math\n\nAlthough Solidity already provides math operators (i.e. `+`, `-`, etc.), Contracts includes [`Math`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Math); a set of utilities for dealing with mathematical operators, with support for extra operations (e.g., [`average`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Math-average-uint256-uint256-)) and [`SignedMath`](https://docs.openzeppelin.com/contracts/5.x/api/utils#SignedMath); a library specialized in signed math operations.\n\nInclude these contracts with `using Math for uint256` or `using SignedMath for int256` and then use their functions in your code:\n\n```solidity hljs\ncontract MyContract {\n    using Math for uint256;\n    using SignedMath for int256;\n\n    function tryOperations(uint256 a, uint256 b) internal pure {\n        (bool succeededAdd, uint256 resultAdd) = x.tryAdd(y);\n        (bool succeededSub, uint256 resultSub) = x.trySub(y);\n        (bool succeededMul, uint256 resultMul) = x.tryMul(y);\n        (bool succeededDiv, uint256 resultDiv) = x.tryDiv(y);\n        // ...\n    }\n\n    function unsignedAverage(int256 a, int256 b) {\n        int256 avg = a.average(b);\n        // ...\n    }\n}\n```\n\nEasy!\n\n|     |     |\n| --- | --- |\n|  | While working with different data types that might require casting, you can use [`SafeCast`](https://docs.openzeppelin.com/contracts/5.x/api/utils#SafeCast) for type casting with added overflow checks. |\n\n## Structures\n\nSome use cases require more powerful data structures than arrays and mappings offered natively in Solidity. Contracts provides these libraries for enhanced data structure management:\n\n- [`BitMaps`](https://docs.openzeppelin.com/contracts/5.x/api/utils#BitMaps): Store packed booleans in storage.\n\n- [`Checkpoints`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Checkpoints): Checkpoint values with built-in lookups.\n\n- [`DoubleEndedQueue`](https://docs.openzeppelin.com/contracts/5.x/api/utils#DoubleEndedQueue): Store items in a queue with `pop()` and `queue()` constant time operations.\n\n- [`EnumerableSet`](https://docs.openzeppelin.com/contracts/5.x/api/utils#EnumerableSet): A [set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) with enumeration capabilities.\n\n- [`EnumerableMap`](https://docs.openzeppelin.com/contracts/5.x/api/utils#EnumerableMap): A `mapping` variant with enumeration capabilities.\n\n- [`MerkleTree`](https://docs.openzeppelin.com/contracts/5.x/api/utils#MerkleTree): An on-chain [Merkle Tree](https://wikipedia.org/wiki/Merkle_Tree) with helper functions.\n\n- [`Heap`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Heap.sol): A\n\n\nThe `Enumerable*` structures are similar to mappings in that they store and remove elements in constant time and don‚Äôt allow for repeated entries, but they also support _enumeration_, which means you can easily query all stored entries both on and off-chain.\n\n### Building a Merkle Tree\n\nBuilding an on-chain Merkle Tree allows developers to keep track of the history of roots in a decentralized manner. For these cases, the [`MerkleTree`](https://docs.openzeppelin.com/contracts/5.x/api/utils#MerkleTree) includes a predefined structure with functions to manipulate the tree (e.g. pushing values or resetting the tree).\n\nThe Merkle Tree does not keep track of the roots intentionally, so that developers can choose their tracking mechanism. Setting up and using a Merkle Tree in Solidity is as simple as follows:\n\n|     |     |\n| --- | --- |\n|  | Functions are exposed without access control for demonstration purposes |\n\n```solidity hljs\nusing MerkleTree for MerkleTree.Bytes32PushTree;\nMerkleTree.Bytes32PushTree private _tree;\n\nfunction setup(uint8 _depth, bytes32 _zero) public /* onlyOwner */ {\n    root = _tree.setup(_depth, _zero);\n}\n\nfunction push(bytes32 leaf) public /* onlyOwner */ {\n    (uint256 leafIndex, bytes32 currentRoot) = _tree.push(leaf);\n    // Store the new root.\n}\n```\n\nThe library also supports custom hashing functions, which can be passed as an extra parameter to the [`push`](https://docs.openzeppelin.com/contracts/5.x/api/utils#MerkleTree-push-struct-MerkleTree-Bytes32PushTree-bytes32-) and [`setup`](https://docs.openzeppelin.com/contracts/5.x/api/utils#MerkleTree-setup-struct-MerkleTree-Bytes32PushTree-uint8-bytes32-) functions.\n\nUsing custom hashing functions is a sensitive operation. After setup, it requires to keep using the same hashing function for every new value pushed to the tree to avoid corrupting the tree. For this reason, it‚Äôs a good practice to keep your hashing function static in your implementation contract as follows:\n\n```solidity hljs\nusing MerkleTree for MerkleTree.Bytes32PushTree;\nMerkleTree.Bytes32PushTree private _tree;\n\nfunction setup(uint8 _depth, bytes32 _zero) public /* onlyOwner */ {\n    root = _tree.setup(_depth, _zero, _hashFn);\n}\n\nfunction push(bytes32 leaf) public /* onlyOwner */ {\n    (uint256 leafIndex, bytes32 currentRoot) = _tree.push(leaf, _hashFn);\n    // Store the new root.\n}\n\nfunction _hashFn(bytes32 a, bytes32 b) internal view returns(bytes32) {\n    // Custom hash function implementation\n    // Kept as an internal implementation detail to\n    // guarantee the same function is always used\n}\n```\n\n### Using a Heap\n\nA [binary heap](https://en.wikipedia.org/wiki/Binary_heap) is a data structure that always stores the most important element at its peak and it can be used as a priority queue.\n\nTo define what is most important in a heap, these frequently take comparator functions that tell the binary heap whether a value has more relevance than another.\n\nOpenZeppelin Contracts implements a Heap data structure with the properties of a binary heap. The heap uses the [`lt`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Comparators-lt-uint256-uint256-) function by default but allows to customize its comparator.\n\nWhen using a custom comparator, it‚Äôs recommended to wrap your function to avoid the possibility of mistakenly using a different comparator function:\n\n```solidity hljs\nfunction pop(Uint256Heap storage self) internal returns (uint256) {\n    return pop(self, Comparators.gt);\n}\n\nfunction insert(Uint256Heap storage self, uint256 value) internal {\n    insert(self, value, Comparators.gt);\n}\n\nfunction replace(Uint256Heap storage self, uint256 newValue) internal returns (uint256) {\n    return replace(self, newValue, Comparators.gt);\n}\n```\n\n## Misc\n\n### Packing\n\nThe storage in the EVM is shaped in chunks of 32 bytes, each of this chunks is known as a _slot_, and can hold multiple values together as long as these values don‚Äôt exceed its size. These properties of the storage allow for a technique known as _packing_, that consists of placing values together on a single storage slot to reduce the costs associated to reading and writing to multiple slots instead of just one.\n\nCommonly, developers pack values using structs that place values together so they fit better in storage. However, this approach requires to load such struct from either calldata or memory. Although sometimes necessary, it may be useful to pack values in a single slot and treat it as a packed value without involving calldata or memory.\n\nThe [`Packing`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Packing) library is a set of utilities for packing values that fit in 32 bytes. The library includes 3 main functionalities:\n\n- Packing 2 `bytesXX` values\n\n- Extracting a packed `bytesXX` value from a `bytesYY`\n\n- Replacing a packed `bytesXX` value from a `bytesYY`\n\n\nWith these primitives, one can build custom functions to create custom packed types. For example, suppose you need to pack an `address` of 20 bytes with a `bytes4` selector and an `uint64` time period:\n\n```solidity hljs\nfunction _pack(address account, bytes4 selector, uint64 period) external pure returns (bytes32) {\n    bytes12 subpack = Packing.pack_4_8(selector, bytes8(period));\n    return Packing.pack_20_12(bytes20(account), subpack);\n}\n\nfunction _unpack(bytes32 pack) external pure returns (address, bytes4, uint64) {\n    return (\n        address(Packing.extract_32_20(pack, 0)),\n        Packing.extract_32_4(pack, 20),\n        uint64(Packing.extract_32_8(pack, 24))\n    );\n}\n```\n\n### Storage Slots\n\nSolidity allocates a storage pointer for each variable declared in a contract. However, there are cases when it‚Äôs required to access storage pointers that can‚Äôt be derived by using regular Solidity.\nFor those cases, the [`StorageSlot`](https://docs.openzeppelin.com/contracts/5.x/api/utils#StorageSlot) library allows for manipulating storage slots directly.\n\n```solidity hljs\nbytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\nfunction _getImplementation() internal view returns (address) {\n    return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n}\n\nfunction _setImplementation(address newImplementation) internal {\n    require(newImplementation.code.length > 0);\n    StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n}\n```\n\nThe [`TransientSlot`](https://docs.openzeppelin.com/contracts/5.x/api/utils#TransientSlot) library supports transient storage through user defined value types ( [UDVTs](https://docs.soliditylang.org/en/latest/types.html#user-defined-value-types)), which enables the same value types as in Solidity.\n\n```solidity hljs\nbytes32 internal constant _LOCK_SLOT = 0xf4678858b2b588224636b8522b729e7722d32fc491da849ed75b3fdf3c84f542;\n\nfunction _getTransientLock() internal view returns (bool) {\n    return _LOCK_SLOT.asBoolean().tload();\n}\n\nfunction _setTransientLock(bool lock) internal {\n    _LOCK_SLOT.asBoolean().tstore(lock);\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Manipulating storage slots directly is an advanced practice. Developers MUST make sure that the storage pointer is not colliding with other variables. |\n\nOne of the most common use cases for writing directly to storage slots is ERC-7201 for namespaced storage, which is guaranteed to not collide with other storage slots derived by Solidity.\n\nUsers can leverage this standard using the [`SlotDerivation`](https://docs.openzeppelin.com/contracts/5.x/api/utils#SlotDerivation) library.\n\n```solidity hljs\nusing SlotDerivation for bytes32;\nstring private constant _NAMESPACE = \"<namespace>\" // eg. example.main\n\nfunction erc7201Pointer() internal view returns (bytes32) {\n    return _NAMESPACE.erc7201Slot();\n}\n```\n\n### Base64\n\n[`Base64`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Base64) util allows you to transform `bytes32` data into its Base64 `string` representation.\n\nThis is especially useful for building URL-safe tokenURIs for both [`ERC-721`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#IERC721Metadata-tokenURI-uint256-) or [`ERC-1155`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155MetadataURI-uri-uint256-). This library provides a clever way to serve URL-safe [Data URI](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/) compliant strings to serve on-chain data structures.\n\nHere is an example to send JSON Metadata through a Base64 Data URI using an ERC-721:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Base64} from \"@openzeppelin/contracts/utils/Base64.sol\";\n\ncontract Base64NFT is ERC721 {\n    using Strings for uint256;\n\n    constructor() ERC721(\"Base64NFT\", \"MTK\") {}\n\n    // ...\n\n    function tokenURI(uint256 tokenId) public pure override returns (string memory) {\n        // Equivalent to:\n        // {\n        //   \"name\": \"Base64NFT #1\",\n        //   // Replace with extra ERC-721 Metadata properties\n        // }\n        // prettier-ignore\n        string memory dataURI = string.concat(\"{\\\"name\\\": \\\"Base64NFT #\", tokenId.toString(), \"\\\"}\");\n\n        return string.concat(\"data:application/json;base64,\", Base64.encode(bytes(dataURI)));\n    }\n}\n```\n\n### Multicall\n\nThe `Multicall` abstract contract comes with a `multicall` function that bundles together multiple calls in a single external call. With it, external accounts may perform atomic operations comprising several function calls. This is not only useful for EOAs to make multiple calls in a single transaction, it‚Äôs also a way to revert a previous call if a later one fails.\n\nConsider this dummy contract:\n\n```solidity hljs\n// contracts/Box.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Multicall} from \"@openzeppelin/contracts/utils/Multicall.sol\";\n\ncontract Box is Multicall {\n    function foo() public {\n        // ...\n    }\n\n    function bar() public {\n        // ...\n    }\n}\n```\n\nThis is how to call the `multicall` function using Ethers.js, allowing `foo` and `bar` to be called in a single transaction:\n\n```javascript hljs\n// scripts/foobar.js\n\nconst instance = await ethers.deployContract(\"Box\");\n\nawait instance.multicall([\\\n    instance.interface.encodeFunctionData(\"foo\"),\\\n    instance.interface.encodeFunctionData(\"bar\")\\\n]);\n```\n\n### Historical Block Hashes\n\n[`Blockhash`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Blockhash) provides L2 protocol developers with extended access to historical block hashes beyond Ethereum‚Äôs native 256-block limit. By leveraging [EIP-2935](https://eips.ethereum.org/EIPS/eip-2935)'s history storage contract, the library enables access to block hashes up to 8,191 blocks in the past, making it invaluable for L2 fraud proofs and state verification systems.\n\nThe library seamlessly combines native `BLOCKHASH` opcode access for recent blocks (‚â§256) with EIP-2935 history storage queries for older blocks (257-8,191). It handles edge cases gracefully by returning zero for future blocks or those beyond the history window, matching the EVM‚Äôs behavior. The implementation uses gas-efficient assembly for static calls to the history storage contract.\n\n```solidity hljs\ncontract L1Inbox {\n    using Blockhash for uint256;\n\n    function verifyBlockHash(uint256 blockNumber, bytes32 expectedHash) public view returns (bool) {\n        return blockNumber.blockHash() == expectedHash;\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | After EIP-2935 activation, it takes 8,191 blocks to completely fill the history storage. Before that, only block hashes since the fork block will be available. |\n\n### Time\n\nThe [`Time`](https://docs.openzeppelin.com/contracts/5.x/api/utils#Time) library provides helpers for manipulating time-related objects in a type-safe manner. It uses `uint48` for timepoints and `uint32` for durations, helping to reduce gas costs while providing adequate precision.\n\nOne of its key features is the `Delay` type, which represents a duration that can automatically change its value at a specified point in the future while maintaining delay guarantees. For example, when reducing a delay value (e.g., from 7 days to 1 day), the change only takes effect after the difference between the old and new delay (i.e. a 6 days) or a minimum setback period, preventing an attacker who gains admin access from immediately reducing security timeouts and executing sensitive operations. This is particularly useful for governance and security mechanisms where timelock periods need to be enforced.\n\nConsider this example for using and safely updating Delays:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport {Time} from \"contracts/utils/types/Time.sol\";\n\ncontract MyDelayedContract {\n    using Time for *;\n\n    Time.Delay private _delay;\n\n    constructor() {\n        _delay = Time.toDelay(3 days);\n    }\n\n    function schedule(bytes32 operationId) external {\n        // Get the current `_delay` value, respecting any pending delay changes if they've taken effect\n        uint32 currentDelay = _delay.get();\n        uint48 executionTime = Time.timestamp() + currentDelay;\n\n        // ... schedule the operation at `executionTime`\n    }\n\n    function execute(bytes32 operationId) external {\n        uint48 executionTime = getExecutionTime(operationId);\n        require(executionTime > 0, \"Operation not scheduled\");\n        require(Time.timestamp() >= executionTime, \"Delay not elapsed yet\");\n\n        // ... execute the operation\n    }\n\n    // Update the delay with `Time`'s safety mechanism\n    function updateDelay(uint32 newDelay) external {\n        (Time.Delay updatedDelay, uint48 effect) = _delay.withUpdate(\n            newDelay,    // The new delay value\n            5 days       // Minimum setback if reducing the delay\n        );\n\n        _delay = updatedDelay;\n\n        // ... emit events\n    }\n\n    // Get complete delay details including pending changes\n    function getDelayDetails() external view returns (\n        uint32 currentValue, // The current delay value\n        uint32 pendingValue, // The pending delay value\n        uint48 effectTime    // The timepoint when the pending delay change takes effect\n    ) {\n        return _delay.getFull();\n    }\n}\n```\n\nThis pattern is used extensively in OpenZeppelin‚Äôs [AccessManager](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager) for implementing secure time-based access control. For example, when changing an admin delay:\n\n```solidity hljs\n// From AccessManager.sol\nfunction _setTargetAdminDelay(address target, uint32 newDelay) internal virtual {\n    uint48 effect;\n    (_targets[target].adminDelay, effect) = _targets[target].adminDelay.withUpdate(\n        newDelay,\n        minSetback()\n    );\n\n    emit TargetAdminDelayUpdated(target, newDelay, effect);\n}\n```\n\n[‚Üê Governance](https://docs.openzeppelin.com/contracts/5.x/governance)\n\n[Subgraphs ‚Üí](https://docs.openzeppelin.com/subgraphs/0.1.x/)","metadata":{"og:title":"Utilities - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","viewport":"width=device-width, initial-scale=1.0","twitter:card":"summary","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","title":"Utilities - OpenZeppelin Docs","language":"en","ogTitle":"Utilities - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"97f0beb4-7b9a-4d7b-af6e-723ff30008f4","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/utilities","url":"https://docs.openzeppelin.com/contracts/5.x/utilities","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1}},{"markdown":"# Contracts Wizard\n\nNot sure where to start? Use the interactive generator below to bootstrap your\ncontract and learn about the components offered in OpenZeppelin Contracts.\n\n|     |     |\n| --- | --- |\n|  | Place the resulting contract in your `contracts` or `src` directory in order to compile it with a tool like Hardhat or Foundry. Consider reading our guide on [Developing Smart Contracts](https://docs.openzeppelin.com/learn/developing-smart-contracts) for more guidance! |\n\nOpenZeppelin Contracts Wizard\n\nMake a token with supply of 10 million What does mintable do? Make a contract for a DAO\n\nI can also edit Wizard settings directly, so from time to time I will update those based on your input.\n\nWiz here üëã. Feel free to ask any questions you have about smart contract development.\n\nAI Assistant\n\n\nAI Assistant\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nNameSymbol\n\nBase URI\n\n\n# Features\n\nMintable\n\nAuto Increment Ids\n\nBurnable\n\nPausable\n\nEnumerable\n\nURI Storage\n\n\n# Votes\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nNameURI\n\n\n# Features\n\nMintable\n\nBurnable\n\nSupply Tracking\n\nPausable\n\nUpdatable URI\n\n\n# Access Control\n\nOwnable\n\nRoles\n\nManaged\n\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\nCustodian\\*\n\n\n# Limitations\\*\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\nCustodian\\*\n\n\n# Limitations\\*\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nName\n\n# Features\n\nSignature Validation\n\nAccount Bound\n\nERC721 Holder\n\nERC1155 Holder\n\nBatched Execution\n\nModules\n\nHooked\n\n\n# Signer\n\nECDSA\n\nEOA Delegation\n\nMultisig\\*\n\nMultisig Weighted\\*\n\nP256\n\nRSA\n\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nName\n\nVoting DelayVoting Period\n\nProposal Threshold\nQuorum\n% \\#\n\nToken decimals:\n\n\nUpdatable Settings\n\nStorage\n\n\n# Votes\n\nERC20Votes\n\nERC721Votes\n\n\n# Token Clock Mode\n\nBlock Number\n\n\n1 block =\n\nseconds\n\nTimestamp\n\n\n# Timelock\n\nTimelockController\n\nCompound\n\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nName\n\n# Features\n\nPausable\n\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n```hljs -solidity grow overflow-auto p-4\n        // SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0\npragma solidity ^0.8.27;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract MyToken is ERC20, ERC20Permit {\n    constructor() ERC20(\"MyToken\", \"MTK\") ERC20Permit(\"MyToken\") {}\n}\n\n\n```\n\n[‚Üê Overview](https://docs.openzeppelin.com/contracts/5.x/)\n\n[Extending Contracts ‚Üí](https://docs.openzeppelin.com/contracts/5.x/extending-contracts)","metadata":{"og:image":"https://docs.openzeppelin.com/_/images/social.png","twitter:card":"summary","ogTitle":"Contracts Wizard - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","language":"en","og:title":"Contracts Wizard - OpenZeppelin Docs","title":"Contracts Wizard - OpenZeppelin Docs","favicon":"https://wizard.openzeppelin.com/favicon.png","viewport":["width=device-width, initial-scale=1.0","width=device-width,initial-scale=1"],"scrapeId":"34478a6e-453d-4e5e-9709-59cd35513fa0","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/wizard","url":"https://docs.openzeppelin.com/contracts/5.x/wizard","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1}},{"markdown":"# Using with Upgrades\n\nIf your contract is going to be deployed with upgradeability, such as using the [OpenZeppelin Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins/), you will need to use the Upgradeable variant of OpenZeppelin Contracts.\n\nThis variant is available as a separate package called `@openzeppelin/contracts-upgradeable`, which is hosted in the repository [OpenZeppelin/openzeppelin-contracts-upgradeable](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable). It uses `@openzeppelin/contracts` as a peer dependency.\n\nIt follows all of the rules for [Writing Upgradeable Contracts](https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable): constructors are replaced by initializer functions, state variables are initialized in initializer functions, and we additionally check for storage incompatibilities across minor versions.\n\n|     |     |\n| --- | --- |\n|  | OpenZeppelin provides a full suite of tools for deploying and securing upgradeable smart contracts. [Check out the full list of resources](https://docs.openzeppelin.com/contracts/5.x/upgradeable#openzeppelin::upgrades.adoc). |\n\n## Overview\n\n### Installation\n\n```console hljs language-shell\n$ npm install @openzeppelin/contracts-upgradeable @openzeppelin/contracts\n```\n\n### Usage\n\nThe Upgradeable package replicates the structure of the main OpenZeppelin Contracts package, but every file and contract has the suffix `Upgradeable`.\n\n```diff hljs\n-import {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n+import {ERC721Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n\n-contract MyCollectible is ERC721 {\n+contract MyCollectible is ERC721Upgradeable {\n```\n\n|     |     |\n| --- | --- |\n|  | Interfaces and libraries are not included in the Upgradeable package, but are instead imported from the main OpenZeppelin Contracts package. |\n\nConstructors are replaced by internal initializer functions following the naming convention `__{ContractName}_init`. Since these are internal, you must always define your own public initializer function and call the parent initializer of the contract you extend.\n\n```diff hljs\n-    constructor() ERC721(\"MyCollectible\", \"MCO\") public {\n+    function initialize() initializer public {\n+        __ERC721_init(\"MyCollectible\", \"MCO\");\n     }\n```\n\n|     |     |\n| --- | --- |\n|  | Use with multiple inheritance requires special attention. See the section below titled [Multiple Inheritance](https://docs.openzeppelin.com/contracts/5.x/upgradeable#multiple-inheritance). |\n\nOnce this contract is set up and compiled, you can deploy it using the [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins/). The following snippet shows an example deployment script using Hardhat.\n\n```js hljs language-javascript\n// scripts/deploy-my-collectible.js\nconst { ethers, upgrades } = require(\"hardhat\");\n\nasync function main() {\n  const MyCollectible = await ethers.getContractFactory(\"MyCollectible\");\n\n  const mc = await upgrades.deployProxy(MyCollectible);\n\n  await mc.waitForDeployment();\n  console.log(\"MyCollectible deployed to:\", await mc.getAddress());\n}\n\nmain();\n```\n\n## Further Notes\n\n### Multiple Inheritance\n\nInitializer functions are not linearized by the compiler like constructors. Because of this, each `__{ContractName}_init` function embeds the linearized calls to all parent initializers. As a consequence, calling two of these `init` functions can potentially initialize the same contract twice.\n\nThe function `__{ContractName}_init_unchained` found in every contract is the initializer function minus the calls to parent initializers, and can be used to avoid the double initialization problem, but doing this manually is not recommended. We hope to be able to implement safety checks for this in future versions of the Upgrades Plugins.\n\n### Namespaced Storage\n\nYou may notice that contracts use a struct with the `@custom:storage-location erc7201:<NAMESPACE_ID>` annotation to store the contract‚Äôs state variables. This follows the [ERC-7201: Namespaced Storage Layout](https://eips.ethereum.org/EIPS/eip-7201) pattern, where each contract has its own storage layout in a namespace that is separate from other contracts in the inheritance chain.\n\nWithout namespaced storage, it isn‚Äôt safe to simply add a state variable because it \"shifts down\" all of the state variables below in the inheritance chain. This makes the storage layouts incompatible, as explained in [Writing Upgradeable Contracts](https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable#modifying-your-contracts).\n\nThe namespaced storage pattern used in the Upgradeable package allows us to freely add new state variables in the future without compromising the storage compatibility with existing deployments. It also allows changing the inheritance order with no impact on the resulting storage layout, as long as all inherited contracts use namespaced storage.\n\n[‚Üê Extending Contracts](https://docs.openzeppelin.com/contracts/5.x/extending-contracts)\n\n[Backwards Compatibility ‚Üí](https://docs.openzeppelin.com/contracts/5.x/backwards-compatibility)","metadata":{"title":"Using with Upgrades - OpenZeppelin Docs","viewport":"width=device-width, initial-scale=1.0","twitter:card":"summary","ogImage":"https://docs.openzeppelin.com/_/images/social.png","ogTitle":"Using with Upgrades - OpenZeppelin Docs","og:title":"Using with Upgrades - OpenZeppelin Docs","language":"en","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","og:image":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"96e12490-a465-418c-8b2f-a0bf8c552dbc","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/upgradeable","url":"https://docs.openzeppelin.com/contracts/5.x/upgradeable","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1}},{"markdown":"# Extending Contracts\n\nMost of the OpenZeppelin Contracts are expected to be used via [inheritance](https://solidity.readthedocs.io/en/latest/contracts.html#inheritance): you will _inherit_ from them when writing your own contracts.\n\nThis is the commonly found `is` syntax, like in `contract MyToken is ERC20`.\n\n|     |     |\n| --- | --- |\n|  | Unlike `contract` s, Solidity `library` s are not inherited from and instead rely on the [`using for`](https://solidity.readthedocs.io/en/latest/contracts.html#using-for) syntax.<br>OpenZeppelin Contracts has some `library` s: most are in the [Utils](https://docs.openzeppelin.com/contracts/5.x/api/utils) directory. |\n\n## Overriding\n\nInheritance is often used to add the parent contract‚Äôs functionality to your own contract, but that‚Äôs not all it can do. You can also _change_ how some parts of the parent behave using _overrides_.\n\nFor example, imagine you want to change [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) so that [`revokeRole`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl-revokeRole-bytes32-address-) can no longer be called. This can be achieved using overrides:\n\n```solidity hljs\n// contracts/AccessControlModified.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract AccessControlModified is AccessControl {\n    error AccessControlNonRevocable();\n\n    // Override the revokeRole function\n    function revokeRole(bytes32, address) public pure override {\n        revert AccessControlNonRevocable();\n    }\n}\n```\n\nThe old `revokeRole` is then replaced by our override, and any calls to it will immediately revert. We cannot _remove_ the function from the contract, but reverting on all calls is good enough.\n\n### Calling `super`\n\nSometimes you want to _extend_ a parent‚Äôs behavior, instead of outright changing it to something else. This is where `super` comes in.\n\nThe `super` keyword will let you call functions defined in a parent contract, even if they are overridden. This mechanism can be used to add additional checks to a function, emit events, or otherwise add functionality as you see fit.\n\n|     |     |\n| --- | --- |\n|  | For more information on how overrides work, head over to the [official Solidity documentation](https://solidity.readthedocs.io/en/latest/contracts.html#index-17). |\n\nHere is a modified version of [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) where [`revokeRole`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl-revokeRole-bytes32-address-) cannot be used to revoke the `DEFAULT_ADMIN_ROLE`:\n\n```solidity hljs\nUnresolved include directive in modules/ROOT/pages/extending-contracts.adoc - include::api:example$access-control/AccessControlNonRevokableAdmin.sol[]\n```\n\nThe `super.revokeRole` statement at the end will invoke `AccessControl`'s original version of `revokeRole`, the same code that would‚Äôve run if there were no overrides in place.\n\n|     |     |\n| --- | --- |\n|  | The same rule is implemented and extended in [`AccessControlDefaultAdminRules`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControlDefaultAdminRules), an extension that also adds enforced security measures for the `DEFAULT_ADMIN_ROLE`. |\n\n## Security\n\nThe maintainers of OpenZeppelin Contracts are mainly concerned with the correctness and security of the code as published in the library, and the combinations of base contracts with the official extensions from the library.\n\nCustom overrides, especially to hooks, can disrupt important assumptions and may introduce security risks in the code that was previously secure. While we try to ensure the contracts remain secure in the face of a wide range of potential customizations, this is done in a best-effort manner. While we try to document all important assumptions, this should not be relied upon. Custom overrides should be carefully reviewed and checked against the source code of the contract they are customizing to fully understand their impact and guarantee their security.\n\nThe way functions interact internally should not be assumed to stay stable across releases of the library. For example, a function that is used in one context in a particular release may not be used in the same context in the next release. Contracts that override functions should revalidate their assumptions when updating the version of OpenZeppelin Contracts they are built on.\n\n[‚Üê Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard)\n\n[Using with Upgrades ‚Üí](https://docs.openzeppelin.com/contracts/5.x/upgradeable)","metadata":{"ogTitle":"Extending Contracts - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","twitter:card":"summary","og:image":"https://docs.openzeppelin.com/_/images/social.png","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","language":"en","title":"Extending Contracts - OpenZeppelin Docs","viewport":"width=device-width, initial-scale=1.0","og:title":"Extending Contracts - OpenZeppelin Docs","scrapeId":"5b7ec5f4-367e-4397-8d75-577fd96ad6e8","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/extending-contracts","url":"https://docs.openzeppelin.com/contracts/5.x/extending-contracts","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1}},{"markdown":"# Frequently Asked Questions\n\n## Can I restrict a function to EOAs only?\n\nWhen calling external addresses from your contract it is unsafe to assume that an address is an externally-owned account (EOA) and not a contract. Attempting to prevent calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract constructor.\n\nAlthough checking that the address has code, `address.code.length > 0`, may seem to differentiate contracts from EOAs, it can only say that an address is currently a contract, and its negation (that an address is not currently a contract) does not imply that the address is an EOA. Some counterexamples are:\n\n- address of a contract in construction\n\n- address where a contract will be created\n\n- address where a contract lived, but was destroyed\n\n\nFurthermore, an address will be considered a contract within the same transaction where it is scheduled for destruction by `SELFDESTRUCT`, which only has an effect at the end of the entire transaction.\n\n[‚Üê Subgraphs](https://docs.openzeppelin.com/subgraphs/0.1.x/)\n\n[Access ‚Üí](https://docs.openzeppelin.com/contracts/5.x/api/access)","metadata":{"ogTitle":"Frequently Asked Questions - OpenZeppelin Docs","title":"Frequently Asked Questions - OpenZeppelin Docs","viewport":"width=device-width, initial-scale=1.0","og:image":"https://docs.openzeppelin.com/_/images/social.png","twitter:card":"summary","og:title":"Frequently Asked Questions - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","ogImage":"https://docs.openzeppelin.com/_/images/social.png","language":"en","scrapeId":"291895d7-bb11-4070-9cf0-9bd3bf40eeb2","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/faq","url":"https://docs.openzeppelin.com/contracts/5.x/faq","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# ERC-6909\n\nERC-6909 is a draft EIP that draws on ERC-1155 learnings since it was published in 2018. The main goals of ERC-6909 is to decrease gas costs and complexity‚Äî‚Äãthis is mainly accomplished by removing batching and callbacks.\n\n|     |     |\n| --- | --- |\n|  | To understand the inspiration for a multi token standard, see the [multi token standard](https://docs.openzeppelin.com/contracts/5.x/erc1155#multi-token-standard) section within the EIP-1155 docs. |\n\n## Changes from ERC-1155\n\nThere are three main changes from ERC-1155 which are as follows:\n\n1. The removal of batch operations.\n\n2. The removal of transfer callbacks.\n\n3. Granularization in approvals‚Äî‚Äãapprovals can be set globally (as operators) or as amounts per token (inspired by ERC20).\n\n\n## Constructing an ERC-6909 Token Contract\n\nWe‚Äôll use ERC-6909 to track multiple items in a game, each having their own unique attributes. All item types will by minted to the deployer of the contract, which we can later transfer to players. We‚Äôll also use the [`ERC6909Metadata`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC6909#ERC6909Metadata) extension to add decimals to our fungible items (the vanilla ERC-6909 implementation does not have decimals).\n\nFor simplicity, we will mint all items in the constructor‚Äî‚Äãhowever, minting functionality could be added to the contract to mint on demand to players.\n\n|     |     |\n| --- | --- |\n|  | For an overview of minting mechanisms, check out [Creating ERC-20 Supply](https://docs.openzeppelin.com/contracts/5.x/erc20-supply). |\n\nHere‚Äôs what a contract for tokenized items might look like:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC6909Metadata} from \"@openzeppelin/contracts/token/ERC6909/extensions/draft-ERC6909Metadata.sol\";\n\ncontract ERC6909GameItems is ERC6909Metadata {\n    uint256 public constant GOLD = 0;\n    uint256 public constant SILVER = 1;\n    uint256 public constant THORS_HAMMER = 2;\n    uint256 public constant SWORD = 3;\n    uint256 public constant SHIELD = 4;\n\n    constructor() {\n        _setDecimals(GOLD, 18);\n        _setDecimals(SILVER, 18);\n        // Default decimals is 0\n        _setDecimals(SWORD, 9);\n        _setDecimals(SHIELD, 9);\n\n        _mint(msg.sender, GOLD, 10 ** 18);\n        _mint(msg.sender, SILVER, 10_000 ** 18);\n        _mint(msg.sender, THORS_HAMMER, 1);\n        _mint(msg.sender, SWORD, 10 ** 9);\n        _mint(msg.sender, SHIELD, 10 ** 9);\n    }\n}\n```\n\nNote that there is no content URI functionality in the base implementation, but the [`ERC6909ContentURI`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC6909#ERC6909ContentURI) extension adds it. Additionally, the base implementation does not track total supplies, but the [`ERC6909TokenSupply`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC6909#ERC6909TokenSupply) extension tracks the total supply of each token id.\n\nOnce the contract is deployed, we will be able to query the deployer‚Äôs balance:\n\n```javascript hljs\n> gameItems.balanceOf(deployerAddress, 3)\n1000000000\n```\n\nWe can transfer items to player accounts:\n\n```javascript hljs\n> gameItems.transfer(playerAddress, 2, 1)\n> gameItems.balanceOf(playerAddress, 2)\n1\n> gameItems.balanceOf(deployerAddress, 2)\n0\n```\n\n[‚Üê ERC-4626](https://docs.openzeppelin.com/contracts/5.x/erc4626)\n\n[Governance ‚Üí](https://docs.openzeppelin.com/contracts/5.x/governance)","metadata":{"ogTitle":"ERC-6909 - OpenZeppelin Docs","language":"en","og:title":"ERC-6909 - OpenZeppelin Docs","twitter:card":"summary","title":"ERC-6909 - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","ogImage":"https://docs.openzeppelin.com/_/images/social.png","viewport":"width=device-width, initial-scale=1.0","og:image":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"2b638345-97bc-48a6-aab0-cd73e0afdebf","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc6909","url":"https://docs.openzeppelin.com/contracts/5.x/erc6909","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# ERC-721\n\nWe‚Äôve discussed how you can make a _fungible_ token using [ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20), but what if not all tokens are alike? This comes up in situations like **real estate**, **voting rights**, or **collectibles**, where some items are valued more than others, due to their usefulness, rarity, etc. ERC-721 is a standard for representing ownership of [_non-fungible_ tokens](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens), that is, where each token is unique.\n\nERC-721 is a more complex standard than ERC-20, with multiple optional extensions, and is split across a number of contracts. The OpenZeppelin Contracts provide flexibility regarding how these are combined, along with custom useful extensions. Check out the [API Reference](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721) to learn more about these.\n\n## Constructing an ERC-721 Token Contract\n\nWe‚Äôll use ERC-721 to track items in our game, which will each have their own unique attributes. Whenever one is to be awarded to a player, it will be minted and sent to them. Players are free to keep their token or trade it with other people as they see fit, as they would any other asset on the blockchain! Please note any account can call `awardItem` to mint items. To restrict what accounts can mint items we can add [Access Control](https://docs.openzeppelin.com/contracts/5.x/access-control).\n\nHere‚Äôs what a contract for tokenized items might look like:\n\n```solidity hljs\n// contracts/GameItem.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC721URIStorage, ERC721} from \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\ncontract GameItem is ERC721URIStorage {\n    uint256 private _nextTokenId;\n\n    constructor() ERC721(\"GameItem\", \"ITM\") {}\n\n    function awardItem(address player, string memory tokenURI) public returns (uint256) {\n        uint256 tokenId = _nextTokenId++;\n        _mint(player, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n\n        return tokenId;\n    }\n}\n```\n\nThe [`ERC721URIStorage`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721URIStorage) contract is an implementation of ERC-721 that includes the metadata standard extensions ( [`IERC721Metadata`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#IERC721Metadata)) as well as a mechanism for per-token metadata. That‚Äôs where the [`_setTokenURI`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721-_setTokenURI-uint256-string-) method comes from: we use it to store an item‚Äôs metadata.\n\nAlso note that, unlike ERC-20, ERC-721 lacks a `decimals` field, since each token is distinct and cannot be partitioned.\n\nNew items can be created:\n\n```javascript hljs\n> gameItem.awardItem(playerAddress, \"https://game.example/item-id-8u5h2m.json\")\nTransaction successful. Transaction hash: 0x...\nEvents emitted:\n - Transfer(0x0000000000000000000000000000000000000000, playerAddress, 7)\n```\n\nAnd the owner and metadata of each item queried:\n\n```javascript hljs\n> gameItem.ownerOf(7)\nplayerAddress\n> gameItem.tokenURI(7)\n\"https://game.example/item-id-8u5h2m.json\"\n```\n\nThis `tokenURI` should resolve to a JSON document that might look something like:\n\n```json hljs\n{\n    \"name\": \"Thor's hammer\",\n    \"description\": \"Mj√∂lnir, the legendary hammer of the Norse god of thunder.\",\n    \"image\": \"https://game.example/item-id-8u5h2m.png\",\n    \"strength\": 20\n}\n```\n\nFor more information about the `tokenURI` metadata JSON Schema, check out the [ERC-721 specification](https://eips.ethereum.org/EIPS/eip-721).\n\n|     |     |\n| --- | --- |\n|  | You‚Äôll notice that the item‚Äôs information is included in the metadata, but that information isn‚Äôt on-chain! So a game developer could change the underlying metadata, changing the rules of the game! |\n\n|     |     |\n| --- | --- |\n|  | If you‚Äôd like to put all item information on-chain, you can extend ERC-721 to do so (though it will be rather costly) by providing a [`Base64`](https://docs.openzeppelin.com/contracts/5.x/utilities#base64) Data URI with the JSON schema encoded. You could also leverage IPFS to store the tokenURI information, but these techniques are out of the scope of this overview guide. |\n\n[‚Üê Creating Supply](https://docs.openzeppelin.com/contracts/5.x/erc20-supply)\n\n[ERC-1155 ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc1155)","metadata":{"language":"en","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","ogImage":"https://docs.openzeppelin.com/_/images/social.png","og:image":"https://docs.openzeppelin.com/_/images/social.png","twitter:card":"summary","viewport":"width=device-width, initial-scale=1.0","og:title":"ERC-721 - OpenZeppelin Docs","ogTitle":"ERC-721 - OpenZeppelin Docs","title":"ERC-721 - OpenZeppelin Docs","scrapeId":"70415d11-7e53-4cba-8160-6ec4bb9794c3","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc721","url":"https://docs.openzeppelin.com/contracts/5.x/erc721","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Creating ERC-20 Supply\n\nIn this guide, you will learn how to create an ERC-20 token with a custom supply mechanism. We will showcase two idiomatic ways to use OpenZeppelin Contracts for this purpose that you will be able to apply to your smart contract development practice.\n\nThe standard interface implemented by tokens built on Ethereum is called ERC-20, and Contracts includes a widely used implementation of it: the aptly named [`ERC20`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20) contract. This contract, like the standard itself, is quite simple and bare-bones. In fact, if you try to deploy an instance of `ERC20` as-is it will be quite literally useless‚Ä¶‚Äã it will have no supply! What use is a token with no supply?\n\nThe way that supply is created is not defined in the ERC-20 document. Every token is free to experiment with its own mechanisms, ranging from the most decentralized to the most centralized, from the most naive to the most researched, and more.\n\n## Fixed Supply\n\nLet‚Äôs say we want a token with a fixed supply of 1000, initially allocated to the account that deploys the contract. If you‚Äôve used Contracts v1, you may have written code like the following:\n\n```solidity hljs\ncontract ERC20FixedSupply is ERC20 {\n    constructor() {\n        totalSupply += 1000;\n        balances[msg.sender] += 1000;\n    }\n}\n```\n\nStarting with Contracts v2, this pattern is not only discouraged, but disallowed. The variables `totalSupply` and `balances` are now private implementation details of `ERC20`, and you can‚Äôt directly write to them. Instead, there is an internal [`_mint`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-_mint-address-uint256-) function that will do exactly this:\n\n```solidity hljs\ncontract ERC20FixedSupply is ERC20 {\n    constructor() ERC20(\"Fixed\", \"FIX\") {\n        _mint(msg.sender, 1000);\n    }\n}\n```\n\nEncapsulating state like this makes it safer to extend contracts. For instance, in the first example we had to manually keep the `totalSupply` in sync with the modified balances, which is easy to forget. In fact, we omitted something else that is also easily forgotten: the `Transfer` event that is required by the standard, and which is relied on by some clients. The second example does not have this bug, because the internal `_mint` function takes care of it.\n\n## Rewarding Miners\n\nThe internal [`_mint`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-_mint-address-uint256-) function is the key building block that allows us to write ERC-20 extensions that implement a supply mechanism.\n\nThe mechanism we will implement is a token reward for the miners that produce Ethereum blocks. In Solidity, we can access the address of the current block‚Äôs miner in the global variable `block.coinbase`. We will mint a token reward to this address whenever someone calls the function `mintMinerReward()` on our token. The mechanism may sound silly, but you never know what kind of dynamic this might result in, and it‚Äôs worth analyzing and experimenting with!\n\n```solidity hljs\ncontract ERC20WithMinerReward is ERC20 {\n    constructor() ERC20(\"Reward\", \"RWD\") {}\n\n    function mintMinerReward() public {\n        _mint(block.coinbase, 1000);\n    }\n}\n```\n\nAs we can see, `_mint` makes it super easy to do this correctly.\n\n## Automating the Reward\n\nSo far our supply mechanism was triggered manually, but `ERC20` also allows us to extend the core functionality of the token through the [`_update`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-_update-address-address-uint256-) function.\n\nAdding to the supply mechanism from the previous section, we can use this function to mint a miner reward for every token transfer that is included in the blockchain.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20WithAutoMinerReward is ERC20 {\n    constructor() ERC20(\"Reward\", \"RWD\") {\n        _mintMinerReward();\n    }\n\n    function _mintMinerReward() internal {\n        _mint(block.coinbase, 1000);\n    }\n\n    function _update(address from, address to, uint256 value) internal virtual override {\n        if (!(from == address(0) && to == block.coinbase)) {\n            _mintMinerReward();\n        }\n        super._update(from, to, value);\n    }\n}\n```\n\n## Wrapping Up\n\nWe‚Äôve seen how to implement an ERC-20 supply mechanism: internally through `_mint`. Hopefully this has helped you understand how to use OpenZeppelin Contracts and some of the design principles behind it, and you can apply them to your own smart contracts.\n\n[‚Üê ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20)\n\n[ERC-721 ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc721)","metadata":{"language":"en","title":"Creating ERC-20 Supply - OpenZeppelin Docs","og:title":"Creating ERC-20 Supply - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","twitter:card":"summary","viewport":"width=device-width, initial-scale=1.0","og:image":"https://docs.openzeppelin.com/_/images/social.png","ogTitle":"Creating ERC-20 Supply - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"eb3e51be-b925-4e55-8062-fa0eaa17a23f","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc20-supply","url":"https://docs.openzeppelin.com/contracts/5.x/erc20-supply","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Backwards Compatibility\n\nOpenZeppelin Contracts uses semantic versioning to communicate backwards compatibility of its API and storage layout. Patch and minor updates will generally be backwards compatible, with rare exceptions as detailed below. Major updates should be assumed incompatible with previous releases. On this page, we provide details about these guarantees.\n\n## API\n\nIn backwards compatible releases, all changes should be either additions or modifications to internal implementation details. Most code should continue to compile and behave as expected. The exceptions to this rule are listed below.\n\n### Security\n\nInfrequently a patch or minor update will remove or change an API in a breaking way, but only if the previous API is considered insecure. These breaking changes will be noted in the changelog and release notes, and published along with a security advisory.\n\n### Draft or Pre-Final ERCs\n\nERCs that are not Final can change in incompatible ways. For this reason, we avoid shipping implementations of ERCs before they are Final. Some exceptions are made for ERCs that have been published for a long time and seem unlikely to change. Implementations for ERCs that may have breaking changes are published in files named `draft-*.sol` to make that condition explicit. There is no backwards compatibility guarantee for content in files prefixed with `draft`.\n\nStandards that have achieved widespread adoption with strong backwards compatibility expectations from the community may be treated as de-facto finalized and published without the `draft-` prefix, as extensive ecosystem reliance makes breaking changes highly unlikely.\n\n### Virtual & Overrides\n\nAlmost all functions in this library are virtual with some exceptions, but this does not mean that overrides are encouraged. There is a subset of functions that are designed to be overridden. By defining overrides outside of this subset you are potentially relying on internal implementation details. We make efforts to preserve backwards compatibility even in these cases but it is extremely difficult and easy to accidentally break. Caution is advised.\n\nAdditionally, some minor updates may result in new compilation errors of the kind \"two or more base classes define function with same name and parameter types\" or \"need to specify overridden contract\", due to what Solidity considers ambiguity in inherited functions. This should be resolved by adding an override that invokes the function via `super`.\n\nSee [Extending Contracts](https://docs.openzeppelin.com/contracts/5.x/extending-contracts) for more about virtual and overrides.\n\n### Structs\n\nStruct members with an underscore prefix should be considered \"private\" and may break in minor versions. Struct data should only be accessed and modified through library functions.\n\n### Errors\n\nThe specific error format and data that is included with reverts should not be assumed stable unless otherwise specified.\n\n### Major Releases\n\nMajor releases should be assumed incompatible. Nevertheless, the external interfaces of contracts will remain compatible if they are standardized, or if the maintainers judge that changing them would cause significant strain on the ecosystem.\n\nAn important aspect that major releases may break is \"upgrade compatibility\", in particular storage layout compatibility. It will never be safe for a live contract to upgrade from one major release to another.\n\n## Storage Layout\n\nMinor and patch updates always preserve storage layout compatibility. This means that a live contract can be upgraded from one minor to another without corrupting the storage layout. In some cases it may be necessary to initialize new state variables when upgrading, although we expect this to be infrequent.\n\nWe recommend using [OpenZeppelin Upgrades Plugins or CLI](https://docs.openzeppelin.com/upgrades-plugins/) to ensure storage layout safety of upgrades.\n\n## Solidity Version\n\nThe minimum Solidity version required to compile the contracts will remain unchanged in minor and patch updates. New contracts introduced in minor releases may make use of newer Solidity features and require a more recent version of the compiler.\n\n[‚Üê Using with Upgrades](https://docs.openzeppelin.com/contracts/5.x/upgradeable)\n\n[Access Control ‚Üí](https://docs.openzeppelin.com/contracts/5.x/access-control)","metadata":{"favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","twitter:card":"summary","language":"en","viewport":"width=device-width, initial-scale=1.0","og:title":"Backwards Compatibility - OpenZeppelin Docs","title":"Backwards Compatibility - OpenZeppelin Docs","ogTitle":"Backwards Compatibility - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","ogImage":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"b81253eb-af8b-4fdf-9480-495aa34a4ba0","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/backwards-compatibility","url":"https://docs.openzeppelin.com/contracts/5.x/backwards-compatibility","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Multisig Account\n\nA multi-signature (multisig) account is a smart account that requires multiple authorized signers to approve operations before execution. Unlike traditional accounts controlled by a single private key, multisigs distribute control among multiple parties, eliminating single points of failure. For example, a 2-of-3 multisig requires signatures from at least 2 out of 3 possible signers.\n\nPopular implementations like [Safe](https://safe.global/) (formerly Gnosis Safe) have become the standard for securing valuable assets. Multisigs provide enhanced security through collective authorization, customizable controls for ownership and thresholds, and the ability to rotate signers without changing the account address.\n\n## Beyond Standard Signature Verification\n\nAs discussed in the [accounts section](https://docs.openzeppelin.com/contracts/5.x/accounts#signature_validation), the standard approach for smart contracts to verify signatures is [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271), which defines an `isValidSignature(hash, signature)`. However, it is limited in two important ways:\n\n1. It assumes the signer has an EVM address\n\n2. It treats the signer as a single identity\n\n\nThis becomes problematic when implementing multisig accounts where:\n\n- You may want to use signers that don‚Äôt have EVM addresses (like keys from hardware devices)\n\n- Each signer needs to be individually verified rather than treated as a collective identity\n\n- You need a threshold system to determine when enough valid signatures are present\n\n\nThe [SignatureChecker](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol) library is useful for verifying EOA and ERC-1271 signatures, but it‚Äôs not designed for more complex arrangements like threshold-based multisigs.\n\n## ERC-7913 Signers\n\n[ERC-7913](https://eips.ethereum.org/EIPS/eip-7913) extends the concept of signer representation to include keys that don‚Äôt have EVM addresses, addressing this limitation. OpenZeppelin implements this standard through three contracts:\n\n### SignerERC7913\n\nThe [`SignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils#SignerERC7913) contract allows a single ERC-7913 formatted signer to control an account. The signer is represented as a `bytes` object that concatenates a verifier address and a key: `verifier || key`.\n\n```solidity hljs\n// contracts/MyAccountERC7913.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.24;\n\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {ERC7739} from \"@openzeppelin/community-contracts/utils/cryptography/signers/ERC7739.sol\";\nimport {ERC7821} from \"@openzeppelin/community-contracts/account/extensions/ERC7821.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SignerERC7913} from \"@openzeppelin/community-contracts/utils/cryptography/signers/SignerERC7913.sol\";\n\ncontract MyAccountERC7913 is Account, SignerERC7913, ERC7739, ERC7821, ERC721Holder, ERC1155Holder, Initializable {\n    constructor() EIP712(\"MyAccount7913\", \"1\") {}\n\n    function initialize(bytes memory signer) public initializer {\n        _setSigner(signer);\n    }\n\n    function setSigner(bytes memory signer) public onlyEntryPointOrSelf {\n        _setSigner(signer);\n    }\n\n    /// @dev Allows the entry point as an authorized executor.\n    function _erc7821AuthorizedExecutor(\n        address caller,\n        bytes32 mode,\n        bytes calldata executionData\n    ) internal view virtual override returns (bool) {\n        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Leaving an account uninitialized may leave it unusable since no public key was associated with it. |\n\n### MultiSignerERC7913\n\nThe [`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913) contract extends this concept to support multiple signers with a threshold-based signature verification system.\n\n```solidity hljs\n// contracts/MyAccountMultiSigner.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.27;\n\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {ERC7739} from \"@openzeppelin/community-contracts/utils/cryptography/signers/ERC7739.sol\";\nimport {ERC7821} from \"@openzeppelin/community-contracts/account/extensions/ERC7821.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {MultiSignerERC7913} from \"@openzeppelin/community-contracts/utils/cryptography/signers/MultiSignerERC7913.sol\";\n\ncontract MyAccountMultiSigner is\n    Account,\n    MultiSignerERC7913,\n    ERC7739,\n    ERC7821,\n    ERC721Holder,\n    ERC1155Holder,\n    Initializable\n{\n    constructor() EIP712(\"MyAccountMultiSigner\", \"1\") {}\n\n    function initialize(bytes[] memory signers, uint256 threshold) public initializer {\n        _addSigners(signers);\n        _setThreshold(threshold);\n    }\n\n    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n        _addSigners(signers);\n    }\n\n    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n        _removeSigners(signers);\n    }\n\n    function setThreshold(uint256 threshold) public onlyEntryPointOrSelf {\n        _setThreshold(threshold);\n    }\n\n    /// @dev Allows the entry point as an authorized executor.\n    function _erc7821AuthorizedExecutor(\n        address caller,\n        bytes32 mode,\n        bytes calldata executionData\n    ) internal view virtual override returns (bool) {\n        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);\n    }\n}\n```\n\nThis implementation is ideal for standard multisig setups where each signer has equal authority, and a fixed number of approvals is required.\n\nThe `MultiSignerERC7913` contract provides several key features for managing multi-signature accounts. It maintains a set of authorized signers and implements a threshold-based system that requires a minimum number of signatures to approve operations. The contract includes an internal interface for managing signers, allowing for the addition and removal of authorized parties.\n\n|     |     |\n| --- | --- |\n|  | `MultiSignerERC7913` safeguards to ensure that the threshold remains achievable based on the current number of active signers, preventing situations where operations could become impossible to execute. |\n\nThe contract also provides public functions for querying signer information: [`isSigner(bytes memory signer)`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913-isSigner-bytes-) to check if a given signer is authorized, [`getSigners(uint64 start, uint64 end)`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913-getSigners-uint64-uint64-) to retrieve a paginated list of authorized signers, and [`getSignerCount()`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913-getSignerCount) to get the total number of signers. These functions are useful when validating signatures, implementing customized access control logic, or building user interfaces that need to display signer information.\n\n### MultiSignerERC7913Weighted\n\nFor more sophisticated governance structures, the [`MultiSignerERC7913Weighted`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913Weighted) contract extends `MultiSignerERC7913` by assigning different weights to each signer.\n\n```solidity hljs\n// contracts/MyAccountMultiSignerWeighted.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.27;\n\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {ERC7739} from \"@openzeppelin/community-contracts/utils/cryptography/signers/ERC7739.sol\";\nimport {ERC7821} from \"@openzeppelin/community-contracts/account/extensions/ERC7821.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {MultiSignerERC7913Weighted} from \"@openzeppelin/community-contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol\";\n\ncontract MyAccountMultiSignerWeighted is\n    Account,\n    MultiSignerERC7913Weighted,\n    ERC7739,\n    ERC7821,\n    ERC721Holder,\n    ERC1155Holder,\n    Initializable\n{\n    constructor() EIP712(\"MyAccountMultiSignerWeighted\", \"1\") {}\n\n    function initialize(bytes[] memory signers, uint256[] memory weights, uint256 threshold) public initializer {\n        _addSigners(signers);\n        _setSignerWeights(signers, weights);\n        _setThreshold(threshold);\n    }\n\n    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n        _addSigners(signers);\n    }\n\n    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {\n        _removeSigners(signers);\n    }\n\n    function setThreshold(uint256 threshold) public onlyEntryPointOrSelf {\n        _setThreshold(threshold);\n    }\n\n    function setSignerWeights(bytes[] memory signers, uint256[] memory weights) public onlyEntryPointOrSelf {\n        _setSignerWeights(signers, weights);\n    }\n\n    /// @dev Allows the entry point as an authorized executor.\n    function _erc7821AuthorizedExecutor(\n        address caller,\n        bytes32 mode,\n        bytes calldata executionData\n    ) internal view virtual override returns (bool) {\n        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);\n    }\n}\n```\n\nThis implementation is perfect for scenarios where different signers should have varying levels of authority, such as:\n\n- Board members with different voting powers\n\n- Organizational structures with hierarchical decision-making\n\n- Hybrid governance systems combining core team and community members\n\n- Execution setups like \"social recovery\" where you trust particular guardians more than others\n\n\nThe `MultiSignerERC7913Weighted` contract extends `MultiSignerERC7913` with a weighting system. Each signer can have a custom weight, and operations require the total weight of signing participants to meet or exceed the threshold. Signers without explicit weights default to a weight of 1.\n\n|     |     |\n| --- | --- |\n|  | When setting up a weighted multisig, ensure the threshold value matches the scale used for signer weights. For example, if signers have weights like 1, 2, or 3, then a threshold of 4 would require at least two signers (e.g., one with weight 1 and one with weight 3). |\n\n## Setting Up a Multisig Account\n\nTo create a multisig account, you need to:\n\n1. Define your signers\n\n2. Determine your threshold\n\n3. Initialize your account with these parameters\n\n\nThe example below demonstrates setting up a 2-of-3 multisig account with different types of signers:\n\n```solidity hljs\n// Example setup code\nfunction setupMultisigAccount() external {\n    // Create signers using different types of keys\n    bytes memory ecdsaSigner = alice; // EOA address (20 bytes)\n\n    // P256 signer with format: verifier || pubKey\n    bytes memory p256Signer = abi.encodePacked(\n        p256Verifier,\n        bobP256PublicKeyX,\n        bobP256PublicKeyY\n    );\n\n    // RSA signer with format: verifier || pubKey\n    bytes memory rsaSigner = abi.encodePacked(\n        rsaVerifier,\n        abi.encode(charlieRSAPublicKeyE, charlieRSAPublicKeyN)\n    );\n\n    // Create array of signers\n    bytes[] memory signers = new bytes[](3);\n    signers[0] = ecdsaSigner;\n    signers[1] = p256Signer;\n    signers[2] = rsaSigner;\n\n    // Set threshold to 2 (2-of-3 multisig)\n    uint256 threshold = 2;\n\n    // Initialize the account\n    myMultisigAccount.initialize(signers, threshold);\n}\n```\n\nFor a weighted multisig, you would also specify weights:\n\n```solidity hljs\n// Example setup for weighted multisig\nfunction setupWeightedMultisigAccount() external {\n    // Create array of signers (same as above)\n    bytes[] memory signers = new bytes[](3);\n    signers[0] = ecdsaSigner;\n    signers[1] = p256Signer;\n    signers[2] = rsaSigner;\n\n    // Assign weights to signers (Alice:1, Bob:2, Charlie:3)\n    uint256[] memory weights = new uint256[](3);\n    weights[0] = 1;\n    weights[1] = 2;\n    weights[2] = 3;\n\n    // Set threshold to 4 (requires at least Bob+Charlie or all three)\n    uint256 threshold = 4;\n\n    // Initialize the weighted account\n    myWeightedMultisigAccount.initialize(signers, weights, threshold);\n}\n```\n\n|     |     |\n| --- | --- |\n|  | The [`_validateReachableThreshold`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913-_validateReachableThreshold--) function ensures that the sum of weights for all active signers meets or exceeds the threshold. Any customization built on top of the multisigner contracts must ensure the threshold is always reachable. |\n\nFor multisig accounts, the signature is a complex structure that contains both the signers and their individual signatures. The format follows ERC-7913‚Äôs specification and must be properly encoded.\n\n### Signature Format\n\nThe multisig signature is encoded as:\n\n```solidity hljs\nabi.encode(\n    bytes[] signers,   // Array of signers sorted by `keccak256`\n    bytes[] signatures // Array of signatures corresponding to each signer\n)\n```\n\nWhere:\n\n- `signers` is an array of the signers participating in this particular signature\n\n- `signatures` is an array of the individual signatures corresponding to each signer\n\n\n|     |     |\n| --- | --- |\n|  | To avoid duplicate signers, the contract uses `keccak256` to generate a unique id for each signer. When providing a multisignature, the `signers` array should be sorted in ascending order by `keccak256`, and the `signatures` array must match the order of their corresponding signers. |\n\n[‚Üê EOA Delegation](https://docs.openzeppelin.com/contracts/5.x/eoa-delegation)\n\n[Tokens ‚Üí](https://docs.openzeppelin.com/contracts/5.x/tokens)","metadata":{"viewport":"width=device-width, initial-scale=1.0","og:title":"Multisig Account - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","title":"Multisig Account - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","language":"en","ogImage":"https://docs.openzeppelin.com/_/images/social.png","ogTitle":"Multisig Account - OpenZeppelin Docs","twitter:card":"summary","scrapeId":"cf59726f-abef-48ce-8117-8c853edfa29a","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/multisig","url":"https://docs.openzeppelin.com/contracts/5.x/multisig","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# ERC-1155\n\nERC-1155 is a novel token standard that aims to take the best from previous standards to create a [**fungibility-agnostic**](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens) and **gas-efficient** [token contract](https://docs.openzeppelin.com/contracts/5.x/tokens#but_first_coffee_a_primer_on_token_contracts).\n\n|     |     |\n| --- | --- |\n|  | ERC-1155 draws ideas from all of [ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20), [ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721), and [ERC-777](https://eips.ethereum.org/EIPS/eip-777). If you‚Äôre unfamiliar with those standards, head to their guides before moving on. |\n\n## Multi Token Standard\n\nThe distinctive feature of ERC-1155 is that it uses a single smart contract to represent multiple tokens at once. This is why its [`balanceOf`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155-balanceOf-address-uint256-) function differs from ERC-20‚Äôs and ERC-777‚Äôs: it has an additional `id` argument for the identifier of the token that you want to query the balance of.\n\nThis is similar to how ERC-721 does things, but in that standard a token `id` has no concept of balance: each token is non-fungible and exists or doesn‚Äôt. The ERC-721 [`balanceOf`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#IERC721-balanceOf-address-) function refers to _how many different tokens_ an account has, not how many of each. On the other hand, in ERC-1155 accounts have a distinct balance for each token `id`, and non-fungible tokens are implemented by simply minting a single one of them.\n\nThis approach leads to massive gas savings for projects that require multiple tokens. Instead of deploying a new contract for each token type, a single ERC-1155 token contract can hold the entire system state, reducing deployment costs and complexity.\n\n## Batch Operations\n\nBecause all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, [`balanceOfBatch`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155-balanceOfBatch-address---uint256---) and [`safeBatchTransferFrom`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155-safeBatchTransferFrom-address-address-uint256---uint256---bytes-), that make querying multiple balances and transferring multiple tokens simpler and less gas-intensive.\n\nIn the spirit of the standard, we‚Äôve also included batch operations in the non-standard functions, such as [`_mintBatch`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#ERC1155-_mintBatch-address-uint256---uint256---bytes-).\n\n## Constructing an ERC-1155 Token Contract\n\nWe‚Äôll use ERC-1155 to track multiple items in our game, which will each have their own unique attributes. We mint all items to the deployer of the contract, which we can later transfer to players. Players are free to keep their tokens or trade them with other people as they see fit, as they would any other asset on the blockchain!\n\nFor simplicity, we will mint all items in the constructor, but you could add minting functionality to the contract to mint on demand to players.\n\n|     |     |\n| --- | --- |\n|  | For an overview of minting mechanisms, check out [Creating ERC-20 Supply](https://docs.openzeppelin.com/contracts/5.x/erc20-supply). |\n\nHere‚Äôs what a contract for tokenized items might look like:\n\n```solidity hljs\n// contracts/GameItems.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract GameItems is ERC1155 {\n    uint256 public constant GOLD = 0;\n    uint256 public constant SILVER = 1;\n    uint256 public constant THORS_HAMMER = 2;\n    uint256 public constant SWORD = 3;\n    uint256 public constant SHIELD = 4;\n\n    constructor() ERC1155(\"https://game.example/api/item/{id}.json\") {\n        _mint(msg.sender, GOLD, 10 ** 18, \"\");\n        _mint(msg.sender, SILVER, 10 ** 27, \"\");\n        _mint(msg.sender, THORS_HAMMER, 1, \"\");\n        _mint(msg.sender, SWORD, 10 ** 9, \"\");\n        _mint(msg.sender, SHIELD, 10 ** 9, \"\");\n    }\n}\n```\n\nNote that for our Game Items, Gold is a fungible token whilst Thor‚Äôs Hammer is a non-fungible token as we minted only one.\n\nThe [`ERC1155`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#ERC1155) contract includes the optional extension [`IERC1155MetadataURI`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155MetadataURI). That‚Äôs where the [`uri`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155MetadataURI-uri-uint256-) function comes from: we use it to retrieve the metadata uri.\n\nAlso note that, unlike ERC-20, ERC-1155 lacks a `decimals` field, since each token is distinct and cannot be partitioned.\n\nOnce deployed, we will be able to query the deployer‚Äôs balance:\n\n```javascript hljs\n> gameItems.balanceOf(deployerAddress,3)\n1000000000\n```\n\nWe can transfer items to player accounts:\n\n```javascript hljs\n> gameItems.safeTransferFrom(deployerAddress, playerAddress, 2, 1, \"0x0\")\n> gameItems.balanceOf(playerAddress, 2)\n1\n> gameItems.balanceOf(deployerAddress, 2)\n0\n```\n\nWe can also batch transfer items to player accounts and get the balance of batches:\n\n```javascript hljs\n> gameItems.safeBatchTransferFrom(deployerAddress, playerAddress, [0,1,3,4], [50,100,1,1], \"0x0\")\n> gameItems.balanceOfBatch([playerAddress,playerAddress,playerAddress,playerAddress,playerAddress], [0,1,2,3,4])\n[50,100,1,1,1]\n```\n\nThe metadata uri can be obtained:\n\n```javascript hljs\n> gameItems.uri(2)\n\"https://game.example/api/item/{id}.json\"\n```\n\nThe `uri` can include the string `{id}` which clients must replace with the actual token ID, in lowercase hexadecimal (with no 0x prefix) and leading zero padded to 64 hex characters.\n\nFor token ID `2` and uri `https://game.example/api/item/{id}.json` clients would replace `{id}` with `0000000000000000000000000000000000000000000000000000000000000002` to retrieve JSON at `https://game.example/api/item/0000000000000000000000000000000000000000000000000000000000000002.json`.\n\nThe JSON document for token ID 2 might look something like:\n\n```json hljs\n{\n    \"name\": \"Thor's hammer\",\n    \"description\": \"Mj√∂lnir, the legendary hammer of the Norse god of thunder.\",\n    \"image\": \"https://game.example/item-id-8u5h2m.png\",\n    \"strength\": 20\n}\n```\n\nFor more information about the metadata JSON Schema, check out the [ERC-1155 Metadata URI JSON Schema](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md#erc-1155-metadata-uri-json-schema).\n\n|     |     |\n| --- | --- |\n|  | You‚Äôll notice that the item‚Äôs information is included in the metadata, but that information isn‚Äôt on-chain! So a game developer could change the underlying metadata, changing the rules of the game! |\n\n|     |     |\n| --- | --- |\n|  | If you‚Äôd like to put all item information on-chain, you can extend ERC-721 to do so (though it will be rather costly) by providing a [`Base64`](https://docs.openzeppelin.com/contracts/5.x/utilities#base64) Data URI with the JSON schema encoded. You could also leverage IPFS to store the URI information, but these techniques are out of the scope of this overview guide |\n\n## Sending Tokens to Contracts\n\nA key difference when using [`safeTransferFrom`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155-safeTransferFrom-address-address-uint256-uint256-bytes-) is that token transfers to other contracts may revert with the following custom error:\n\n```text hljs\nERC1155InvalidReceiver(\"<ADDRESS>\")\n```\n\nThis is a good thing! It means that the recipient contract has not registered itself as aware of the ERC-1155 protocol, so transfers to it are disabled to **prevent tokens from being locked forever**. As an example, [the Golem contract currently holds over 350k `GNT` tokens](https://etherscan.io/token/0xa74476443119A942dE498590Fe1f2454d7D4aC0d?a=0xa74476443119A942dE498590Fe1f2454d7D4aC0d), and lacks methods to get them out of there. This has happened to virtually every ERC20-backed project, usually due to user error.\n\nIn order for our contract to receive ERC-1155 tokens we can inherit from the convenience contract [`ERC1155Holder`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#ERC1155Holder) which handles the registering for us. However, we need to remember to implement functionality to allow tokens to be transferred out of our contract:\n\n```solidity hljs\n// contracts/MyERC115HolderContract.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\ncontract MyERC115HolderContract is ERC1155Holder {}\n```\n\nWe can also implement more complex scenarios using the [`onERC1155Received`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155Receiver-onERC1155Received-address-address-uint256-uint256-bytes-) and [`onERC1155BatchReceived`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#IERC1155Receiver-onERC1155BatchReceived-address-address-uint256---uint256---bytes-) functions.\n\n[‚Üê ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721)\n\n[ERC-4626 ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc4626)","metadata":{"favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","twitter:card":"summary","viewport":"width=device-width, initial-scale=1.0","ogImage":"https://docs.openzeppelin.com/_/images/social.png","og:title":"ERC-1155 - OpenZeppelin Docs","title":"ERC-1155 - OpenZeppelin Docs","language":"en","ogTitle":"ERC-1155 - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"fcda384e-7c1a-4d4c-b033-a5901987db0c","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc1155","url":"https://docs.openzeppelin.com/contracts/5.x/erc1155","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# How to set up on-chain governance\n\nIn this guide we will learn how OpenZeppelin‚Äôs Governor contract works, how to set it up, and how to use it to create proposals, vote for them, and execute them, using tools provided by Ethers.js and Tally.\n\n|     |     |\n| --- | --- |\n|  | Find detailed contract documentation at [Governance API](https://docs.openzeppelin.com/contracts/5.x/api/governance). |\n\n## Introduction\n\nDecentralized protocols are in constant evolution from the moment they are publicly released. Often, the initial team retains control of this evolution in the first stages, but eventually delegates it to a community of stakeholders. The process by which this community makes decisions is called on-chain governance, and it has become a central component of decentralized protocols, fueling varied decisions such as parameter tweaking, smart contract upgrades, integrations with other protocols, treasury management, grants, etc.\n\nThis governance protocol is generally implemented in a special-purpose contract called ‚ÄúGovernor‚Äù. The GovernorAlpha and GovernorBravo contracts designed by Compound have been very successful and popular so far, with the downside that projects with different requirements have had to fork the code to customize it for their needs, which can pose a high risk of introducing security issues. For OpenZeppelin Contracts, we set out to build a modular system of Governor contracts so that forking is not needed, and different requirements can be accommodated by writing small modules using Solidity inheritance. You will find the most common requirements out of the box in OpenZeppelin Contracts, but writing additional ones is simple, and we will be adding new features as requested by the community in future releases. Additionally, the design of OpenZeppelin Governor requires minimal use of storage and results in more gas efficient operation.\n\n## Compatibility\n\nOpenZeppelin‚Äôs Governor system was designed with a concern for compatibility with existing systems that were based on Compound‚Äôs GovernorAlpha and GovernorBravo. Because of this, you will find that many modules are presented in two variants, one of which is built for compatibility with those systems.\n\n### ERC20Votes & ERC20VotesComp\n\nThe ERC-20 extension to keep track of votes and vote delegation is one such case. The shorter one is the more generic version because it can support token supplies greater than 2^96, while the ‚ÄúComp‚Äù variant is limited in that regard, but exactly fits the interface of the COMP token that is used by GovernorAlpha and Bravo. Both contract variants share the same events, so they are fully compatible when looking at events only.\n\n### Governor & GovernorStorage\n\nAn OpenZeppelin Governor contract is not interface-compatible with Compound‚Äôs GovernorAlpha or Bravo. Even though events are fully compatible, proposal lifecycle functions (creation, execution, etc.) have different signatures that are meant to optimize storage use. Other functions from GovernorAlpha and Bravo are likewise not available. It‚Äôs possible to opt in some Bravo-like behavior by inheriting from the GovernorStorage module. This module provides proposal enumerability and alternate versions of the `queue`, `execute` and `cancel` function that only take the proposal id. This module reduces the calldata needed by some operations in exchange for an increased storage footprint. This might be a good trade-off for some L2 chains. It also provides primitives for indexer-free frontends.\n\nNote that even with the use of this module, one important difference with Compound‚Äôs GovernorBravo is the way that \\`proposalId\\`s are calculated. Governor uses the hash of the proposal parameters with the purpose of keeping its data off-chain by event indexing, while the original Bravo implementation uses sequential \\`proposalId\\`s.\n\n### GovernorTimelockControl & GovernorTimelockCompound\n\nWhen using a timelock with your Governor contract, you can use either OpenZeppelin‚Äôs TimelockController or Compound‚Äôs Timelock. Based on the choice of timelock, you should choose the corresponding Governor module: GovernorTimelockControl or GovernorTimelockCompound respectively. This allows you to migrate an existing GovernorAlpha instance to an OpenZeppelin-based Governor without changing the timelock in use.\n\n### Tally\n\n[Tally](https://www.tally.xyz/) is a full-fledged application for user owned on-chain governance. It comprises a voting dashboard, proposal creation wizard, real time research and analysis, and educational content.\n\nFor all of these options, the Governor will be compatible with Tally: users will be able to create proposals, see voting periods and delays following [IERC6372](https://docs.openzeppelin.com/contracts/5.x/api/interfaces#IERC6372), visualize voting power and advocates, navigate proposals, and cast votes. For proposal creation in particular, projects can also use [Defender Transaction Proposals](https://docs.openzeppelin.com/defender/module/actions#transaction-proposals-reference) as an alternative interface.\n\nIn the rest of this guide, we will focus on a fresh deploy of the vanilla OpenZeppelin Governor features without concern for compatibility with GovernorAlpha or Bravo.\n\n## Setup\n\n### Token\n\nThe voting power of each account in our governance setup will be determined by an ERC-20 token. The token has to implement the ERC20Votes extension. This extension will keep track of historical balances so that voting power is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Votes} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {Nonces} from \"@openzeppelin/contracts/utils/Nonces.sol\";\n\ncontract MyToken is ERC20, ERC20Permit, ERC20Votes {\n    constructor() ERC20(\"MyToken\", \"MTK\") ERC20Permit(\"MyToken\") {}\n\n    // The functions below are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._update(from, to, amount);\n    }\n\n    function nonces(address owner) public view virtual override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n}\n```\n\nIf your project already has a live token that does not include ERC20Votes and is not upgradeable, you can wrap it in a governance token by using ERC20Wrapper. This will allow token holders to participate in governance by wrapping their tokens 1-to-1.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20, ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Votes} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {ERC20Wrapper} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Wrapper.sol\";\nimport {Nonces} from \"@openzeppelin/contracts/utils/Nonces.sol\";\n\ncontract MyTokenWrapped is ERC20, ERC20Permit, ERC20Votes, ERC20Wrapper {\n    constructor(\n        IERC20 wrappedToken\n    ) ERC20(\"MyTokenWrapped\", \"MTK\") ERC20Permit(\"MyTokenWrapped\") ERC20Wrapper(wrappedToken) {}\n\n    // The functions below are overrides required by Solidity.\n\n    function decimals() public view override(ERC20, ERC20Wrapper) returns (uint8) {\n        return super.decimals();\n    }\n\n    function _update(address from, address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._update(from, to, amount);\n    }\n\n    function nonces(address owner) public view virtual override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | The only other source of voting power available in OpenZeppelin Contracts currently is [`ERC721Votes`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721Votes). ERC-721 tokens that don‚Äôt provide this functionality can be wrapped into a voting tokens using a combination of [`ERC721Votes`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721Votes) and [`ERC721Wrapper`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721Wrapper). |\n\n|     |     |\n| --- | --- |\n|  | The internal clock used by the token to store voting balances will dictate the operating mode of the Governor contract attached to it. By default, block numbers are used. Since v4.9, developers can override the [IERC6372](https://docs.openzeppelin.com/contracts/5.x/api/interfaces#IERC6372) clock to use timestamps instead of block numbers. |\n\n### Governor\n\nInitially, we will build a Governor without a timelock. The core logic is given by the Governor contract, but we still need to choose: 1) how voting power is determined, 2) how many votes are needed for quorum, 3) what options people have when casting a vote and how those votes are counted, and 4) what type of token should be used to vote. Each of these aspects is customizable by writing your own module, or more easily choosing one from OpenZeppelin Contracts.\n\nFor 1) we will use the GovernorVotes module, which hooks to an IVotes instance to determine the voting power of an account based on the token balance they hold when a proposal becomes active. This module requires as a constructor parameter the address of the token. This module also discovers the clock mode (ERC-6372) used by the token and applies it to the Governor.\n\nFor 2) we will use GovernorVotesQuorumFraction which works together with ERC20Votes to define quorum as a percentage of the total supply at the block a proposal‚Äôs voting power is retrieved. This requires a constructor parameter to set the percentage. Most Governors nowadays use 4%, so we will initialize the module with parameter 4 (this indicates the percentage, resulting in 4%).\n\nFor 3) we will use GovernorCountingSimple, a module that offers 3 options to voters: For, Against, and Abstain, and where only For and Abstain votes are counted towards quorum.\n\nBesides these modules, Governor itself has some parameters we must set.\n\nvotingDelay: How long after a proposal is created should voting power be fixed. A large voting delay gives users time to unstake tokens if necessary.\n\nvotingPeriod: How long does a proposal remain open to votes.\n\nThese parameters are specified in the unit defined in the token‚Äôs clock. Assuming the token uses block numbers, and assuming block time of around 12 seconds, we will have set votingDelay = 1 day = 7200 blocks, and votingPeriod = 1 week = 50400 blocks.\n\nWe can optionally set a proposal threshold as well. This restricts proposal creation to accounts that have enough voting power.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {Governor} from \"@openzeppelin/contracts/governance/Governor.sol\";\nimport {GovernorCountingSimple} from \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport {GovernorVotes} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {GovernorVotesQuorumFraction} from \"@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport {GovernorTimelockControl} from \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ncontract MyGovernor is\n    Governor,\n    GovernorCountingSimple,\n    GovernorVotes,\n    GovernorVotesQuorumFraction,\n    GovernorTimelockControl\n{\n    constructor(\n        IVotes _token,\n        TimelockController _timelock\n    ) Governor(\"MyGovernor\") GovernorVotes(_token) GovernorVotesQuorumFraction(4) GovernorTimelockControl(_timelock) {}\n\n    function votingDelay() public pure override returns (uint256) {\n        return 7200; // 1 day\n    }\n\n    function votingPeriod() public pure override returns (uint256) {\n        return 50400; // 1 week\n    }\n\n    function proposalThreshold() public pure override returns (uint256) {\n        return 0;\n    }\n\n    // The functions below are overrides required by Solidity.\n\n    function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) {\n        return super.state(proposalId);\n    }\n\n    function proposalNeedsQueuing(\n        uint256 proposalId\n    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {\n        return super.proposalNeedsQueuing(proposalId);\n    }\n\n    function _queueOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint48) {\n        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _executeOperations(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n}\n```\n\n### Timelock\n\nIt is good practice to add a timelock to governance decisions. This allows users to exit the system if they disagree with a decision before it is executed. We will use OpenZeppelin‚Äôs TimelockController in combination with the GovernorTimelockControl module.\n\n|     |     |\n| --- | --- |\n|  | When using a timelock, it is the timelock that will execute proposals and thus the timelock that should hold any funds, ownership, and access control roles. Before version 4.5 there was no way to recover funds in the Governor contract when using a timelock! Before version 4.3, when using the Compound Timelock, ETH in the timelock was not easily accessible. |\n\nTimelockController uses an AccessControl setup that we need to understand in order to set up roles.\n\n- The Proposer role is in charge of queueing operations: this is the role the Governor instance should be granted, and it should likely be the only proposer in the system.\n\n- The Executor role is in charge of executing already available operations: we can assign this role to the special zero address to allow anyone to execute (if operations can be particularly time sensitive, the Governor should be made Executor instead).\n\n- Lastly, there is the Admin role, which can grant and revoke the two previous roles: this is a very sensitive role that will be granted automatically to the timelock itself, and optionally to a second account, which can be used for ease of setup but should promptly renounce the role.\n\n\n## Proposal Lifecycle\n\nLet‚Äôs walk through how to create and execute a proposal on our newly deployed Governor.\n\nA proposal is a sequence of actions that the Governor contract will perform if it passes. Each action consists of a target address, calldata encoding a function call, and an amount of ETH to include. Additionally, a proposal includes a human-readable description.\n\n### Create a Proposal\n\nLet‚Äôs say we want to create a proposal to give a team a grant, in the form of ERC-20 tokens from the governance treasury. This proposal will consist of a single action where the target is the ERC-20 token, calldata is the encoded function call `transfer(<team wallet>, <grant amount>)`, and with 0 ETH attached.\n\nGenerally a proposal will be created with the help of an interface such as Tally or [Defender Proposals](https://docs.openzeppelin.com/defender/module/actions#transaction-proposals-reference). Here we will show how to create the proposal using Ethers.js.\n\nFirst we get all the parameters necessary for the proposal action.\n\n```javascript hljs\nconst tokenAddress = ...;\nconst token = await ethers.getContractAt(‚ÄòERC20‚Äô, tokenAddress);\n\nconst teamAddress = ...;\nconst grantAmount = ...;\nconst transferCalldata = token.interface.encodeFunctionData(‚Äòtransfer‚Äô, [teamAddress, grantAmount]);\n```\n\nNow we are ready to call the propose function of the Governor. Note that we don‚Äôt pass in one array of actions, but instead three arrays corresponding to the list of targets, the list of values, and the list of calldatas. In this case it‚Äôs a single action, so it‚Äôs simple:\n\n```javascript hljs\nawait governor.propose(\n  [tokenAddress],\n  [0],\n  [transferCalldata],\n  ‚ÄúProposal #1: Give grant to team‚Äù,\n);\n```\n\nThis will create a new proposal, with a proposal id that is obtained by hashing together the proposal data, and which will also be found in an event in the logs of the transaction.\n\n### Cast a Vote\n\nOnce a proposal is active, delegates can cast their vote. Note that it is delegates who carry voting power: if a token holder wants to participate, they can set a trusted representative as their delegate, or they can become a delegate themselves by self-delegating their voting power.\n\nVotes are cast by interacting with the Governor contract through the `castVote` family of functions. Voters would generally invoke this from a governance UI such as Tally.\n\n![Voting in Tally](https://docs.openzeppelin.com/contracts/5.x/_images/tally-vote.png)\n\n### Execute the Proposal\n\nOnce the voting period is over, if quorum was reached (enough voting power participated) and the majority voted in favor, the proposal is considered successful and can proceed to be executed. Once a proposal passes, it can be queued and executed from the same place you voted.\n\n![Administration Panel in Tally](https://docs.openzeppelin.com/contracts/5.x/_images/tally-exec.png)\n\nWe will see now how to do this manually using Ethers.js.\n\nIf a timelock was set up, the first step to execution is queueing. You will notice that both the queue and execute functions require passing in the entire proposal parameters, as opposed to just the proposal id. This is necessary because this data is not stored on chain, as a measure to save gas. Note that these parameters can always be found in the events emitted by the contract. The only parameter that is not sent in its entirety is the description, since this is only needed in its hashed form to compute the proposal id.\n\nTo queue, we call the queue function:\n\n```javascript hljs\nconst descriptionHash = ethers.utils.id(‚ÄúProposal #1: Give grant to team‚Äù);\n\nawait governor.queue(\n  [tokenAddress],\n  [0],\n  [transferCalldata],\n  descriptionHash,\n);\n```\n\nThis will cause the Governor to interact with the timelock contract and queue the actions for execution after the required delay.\n\nAfter enough time has passed (according to the timelock parameters), the proposal can be executed. If there was no timelock to begin with, this step can be ran immediately after the proposal succeeds.\n\n```javascript hljs\nawait governor.execute(\n  [tokenAddress],\n  [0],\n  [transferCalldata],\n  descriptionHash,\n);\n```\n\nExecuting the proposal will transfer the ERC-20 tokens to the chosen recipient. To wrap up: we set up a system where a treasury is controlled by the collective decision of the token holders of a project, and all actions are executed via proposals enforced by on-chain votes.\n\n## Timestamp based governance\n\n### Motivation\n\nIt is sometimes difficult to deal with durations expressed in number of blocks because of inconsistent or unpredictable time between blocks. This is particularly true of some L2 networks where blocks are produced based on blockchain usage. Using number of blocks can also lead to the governance rules being affected by network upgrades that modify the expected time between blocks.\n\nThe difficulty of replacing block numbers with timestamps is that the Governor and the token must both use the same format when querying past votes. If a token is designed around block numbers, it is not possible for a Governor to reliably do timestamp based lookups.\n\nTherefore, designing a timestamp based voting system starts with the token.\n\n### Token\n\nSince v4.9, all voting contracts (including [`ERC20Votes`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20Votes) and [`ERC721Votes`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721Votes)) rely on [IERC6372](https://docs.openzeppelin.com/contracts/5.x/api/interfaces#IERC6372) for clock management. In order to change from operating with block numbers to operating with timestamps, all that is required is to override the `clock()` and `CLOCK_MODE()` functions.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Votes} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport {Nonces} from \"@openzeppelin/contracts/utils/Nonces.sol\";\n\ncontract MyTokenTimestampBased is ERC20, ERC20Permit, ERC20Votes {\n    constructor() ERC20(\"MyTokenTimestampBased\", \"MTK\") ERC20Permit(\"MyTokenTimestampBased\") {}\n\n    // Overrides IERC6372 functions to make the token & governor timestamp-based\n\n    function clock() public view override returns (uint48) {\n        return uint48(block.timestamp);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public pure override returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    // The functions below are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._update(from, to, amount);\n    }\n\n    function nonces(address owner) public view virtual override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n}\n```\n\n### Governor\n\nThe Governor will automatically detect the clock mode used by the token and adapt to it. There is no need to override anything in the Governor contract. However, the clock mode does affect how some values are interpreted. It is therefore necessary to set the `votingDelay()` and `votingPeriod()` accordingly.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Governor} from \"@openzeppelin/contracts/governance/Governor.sol\";\nimport {GovernorCountingSimple} from \"@openzeppelin/contracts/governance/compatibility/GovernorCountingSimple.sol\";\nimport {GovernorVotes} from \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport {GovernorVotesQuorumFraction} from \"@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport {GovernorTimelockControl} from \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\nimport {TimelockController} from \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport {IVotes} from \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\n\ncontract MyGovernor is Governor, GovernorCountingSimple, GovernorVotes, GovernorVotesQuorumFraction, GovernorTimelockControl {\n    constructor(IVotes _token, TimelockController _timelock)\n        Governor(\"MyGovernor\")\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(4)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    function votingDelay() public pure virtual override returns (uint256) {\n        return 1 days;\n    }\n\n    function votingPeriod() public pure virtual override returns (uint256) {\n        return 1 weeks;\n    }\n\n    function proposalThreshold() public pure virtual override returns (uint256) {\n        return 0;\n    }\n\n    // ...\n}\n```\n\n### Disclaimer\n\nTimestamp based voting is a recent feature that was formalized in ERC-6372 and ERC-5805, and introduced in v4.9. At the time this feature is released, some governance tooling may not support it yet. Users can expect invalid reporting of deadlines & durations if the tool is not able to interpret the ERC6372 clock. This invalid reporting by offchain tools does not affect the onchain security and functionality of the governance contract.\n\nGovernors with timestamp support (v4.9 and above) are compatible with old tokens (before v4.9) and will operate in \"block number\" mode (which is the mode all old tokens operate on). On the other hand, old Governor instances (before v4.9) are not compatible with new tokens operating using timestamps. If you update your token code to use timestamps, make sure to also update your Governor code.\n\n[‚Üê ERC-6909](https://docs.openzeppelin.com/contracts/5.x/erc6909)\n\n[Utilities ‚Üí](https://docs.openzeppelin.com/contracts/5.x/utilities)","metadata":{"twitter:card":"summary","ogTitle":"How to set up on-chain governance - OpenZeppelin Docs","language":"en","ogImage":"https://docs.openzeppelin.com/_/images/social.png","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","og:title":"How to set up on-chain governance - OpenZeppelin Docs","title":"How to set up on-chain governance - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","viewport":"width=device-width, initial-scale=1.0","scrapeId":"9aac9952-7b70-4430-9a4a-690f51665b79","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/governance","url":"https://docs.openzeppelin.com/contracts/5.x/governance","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Tokens\n\nAh, the \"token\": blockchain‚Äôs most powerful and most misunderstood tool.\n\nA token is a _representation of something in the blockchain_. This something can be money, time, services, shares in a company, a virtual pet, anything. By representing things as tokens, we can allow smart contracts to interact with them, exchange them, create or destroy them.\n\n## But First, Coffee a Primer on Token Contracts\n\nMuch of the confusion surrounding tokens comes from two concepts getting mixed up: _token contracts_ and the actual _tokens_.\n\nA _token contract_ is simply an Ethereum smart contract. \"Sending tokens\" actually means \"calling a method on a smart contract that someone wrote and deployed\". At the end of the day, a token contract is not much more than a mapping of addresses to balances, plus some methods to add and subtract from those balances.\n\nIt is these balances that represent the _tokens_ themselves. Someone \"has tokens\" when their balance in the token contract is non-zero. That‚Äôs it! These balances could be considered money, experience points in a game, deeds of ownership, or voting rights, and each of these tokens would be stored in different token contracts.\n\n## Different Kinds of Tokens\n\nNote that there‚Äôs a big difference between having two voting rights and two deeds of ownership: each vote is equal to all others, but houses usually are not! This is called [fungibility](https://en.wikipedia.org/wiki/Fungibility). _Fungible goods_ are equivalent and interchangeable, like Ether, fiat currencies, and voting rights. _Non-fungible_ goods are unique and distinct, like deeds of ownership, or collectibles.\n\nIn a nutshell, when dealing with non-fungibles (like your house) you care about _which ones_ you have, while in fungible assets (like your bank account statement) what matters is _how much_ you have.\n\n## Standards\n\nEven though the concept of a token is simple, they have a variety of complexities in the implementation. Because everything in Ethereum is just a smart contract, and there are no rules about what smart contracts have to do, the community has developed a variety of **standards** (called EIPs or ERCs) for documenting how a contract can interoperate with other contracts.\n\nYou‚Äôve probably heard of the ERC-20 or ERC-721 token standards, and that‚Äôs why you‚Äôre here. Head to our specialized guides to learn more about these:\n\n- [ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20): the most widespread token standard for fungible assets, albeit somewhat limited by its simplicity.\n\n- [ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721): the de-facto solution for non-fungible tokens, often used for collectibles and games.\n\n- [ERC-1155](https://docs.openzeppelin.com/contracts/5.x/erc1155): a novel standard for multi-tokens, allowing for a single contract to represent multiple fungible and non-fungible tokens, along with batched operations for increased gas efficiency.\n\n\n[‚Üê Multisig](https://docs.openzeppelin.com/contracts/5.x/multisig)\n\n[ERC-20 ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc20)","metadata":{"twitter:card":"summary","language":"en","title":"Tokens - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","viewport":"width=device-width, initial-scale=1.0","og:title":"Tokens - OpenZeppelin Docs","ogTitle":"Tokens - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"1511b9e7-20a6-4050-9338-976ca73e4438","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/tokens","url":"https://docs.openzeppelin.com/contracts/5.x/tokens","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# EOA Delegation\n\n[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) introduces a new transaction type ( `0x4`) that grants [Externally Owned Accounts (EOAs)](https://ethereum.org/en/developers/docs/accounts/) the ability to delegate execution to an smart contract. This is particularly useful to enable traditional EVM accounts to:\n\n- Batch multiple operations in a single transaction (e.g. [`approve`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#IERC20-approve-address-uint256-) \\+ [`transfer`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#IERC20-transfer-address-uint256-), yey!)\n\n- Sponsoring transactions for other users.\n\n- Implementing privilege de-escalation (e.g., sub-keys with limited permissions)\n\n\nThis section walks you through the process of delegating an EOA to a contract following [ERC-7702](https://eips.ethereum.org/EIPS/eip-7702). This allows you to use your EOA‚Äôs private key to sign and execute operations with custom execution logic. Combined with [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) infrastructure, users can achieve gas sponsoring through [paymasters](https://docs.openzeppelin.com/community-contracts/paymasters).\n\n## Delegating execution\n\nEIP-7702 enables EOAs to delegate their execution capabilities to smart contracts, effectively bridging the gap between traditional and [Smart Accounts](https://docs.openzeppelin.com/contracts/5.x/accounts). The [`SignerERC7702`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography) utility facilitates this delegation by verifying signatures against the EOA‚Äôs address ( `address(this)`), making it easier to implement EIP-7702 in smart contract accounts.\n\n```solidity hljs\n// contracts/MyAccountERC7702.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Account} from \"@openzeppelin/contracts/account/Account.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {ERC7821} from \"@openzeppelin/contracts/account/extensions/draft-ERC7821.sol\";\nimport {SignerERC7702} from \"@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol\";\n\ncontract MyAccountERC7702 is Account, SignerERC7702, ERC7821, ERC721Holder, ERC1155Holder {\n    /// @dev Allows the entry point as an authorized executor.\n    function _erc7821AuthorizedExecutor(\n        address caller,\n        bytes32 mode,\n        bytes calldata executionData\n    ) internal view virtual override returns (bool) {\n        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Users can delegate to an instance of [`ERC-7821`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC7821) for a minimal batch executor that does not use ERC-4337 related code. |\n\n### Signing Authorization\n\nTo authorize delegation, the EOA owner signs a message containing the chain ID, nonce, delegation address, and signature components (i.e. `[chain_id, address, nonce, y_parity, r, s]`). This signed authorization serves two purposes: it restricts execution to only the delegate contract and prevents replay attacks.\n\nThe EOA maintains a delegation designator for each authorized address on each chain, which points to the contract whose code will be executed in the EOA‚Äôs context to handle delegated operations.\n\nHere‚Äôs how to construct an authorization with [viem](https://viem.sh/):\n\n```typescript hljs\n// Remember not to hardcode your private key!\nconst eoa = privateKeyToAccount('<YOUR_PRIVATE_KEY>');\nconst eoaClient = createWalletClient({\n  account: eoa,\n  chain: publicClient.chain,\n  transport: http(),\n});\n\nconst walletClient = createWalletClient({\n  account, // See Viem's `privateKeyToAccount`\n  chain, // import { ... } from 'viem/chains';\n  transport: http(),\n})\n\nconst authorization = await eoaClient.signAuthorization({\n  account: walletClient.account.address,\n  contractAddress: '0x<YOUR_DELEGATE_CONTRACT_ADDRESS>',\n  // Use instead of `account` if your\n  // walletClient's account is the one sending the transaction\n  // executor: \"self\",\n});\n```\n\n|     |     |\n| --- | --- |\n|  | When implementing delegate contracts, ensure they require signatures that avoid replayability (e.g. a domain separator, nonce).<br>A poorly implemented delegate can allow a malicious actor to take near complete control over a signer‚Äôs EOA. |\n\n### Send a Set Code Transaction\n\nAfter signing the authorization, you need to send a `SET_CODE_TX_TYPE` (0x04) transaction to write the delegation designator (i.e. `0xef0100 || address`) to your EOA‚Äôs code, which tells the EVM to load and execute code from the specified address when operations are performed on your EOA.\n\n```typescript hljs\n// Send the `authorization` along with `data`\nconst receipt = await walletClient\n  .sendTransaction({\n    authorizationList: [authorization],\n    data: '0x<CALLDATA_TO_EXECUTE_IN_THE_ACCOUNT>',\n    to: eoa.address,\n  })\n  .then((txHash) =>\n    publicClient.waitForTransactionReceipt({\n      hash: txHash,\n    })\n  );\n\n// Print receipt\nconsole.log(userOpReceipt);\n```\n\nTo remove the delegation and restore your EOA to its original state, you can send a `SET_CODE_TX_TYPE` transaction with an authorization tuple that points to the zero address ( `0x0000000000000000000000000000000000000000`). This will clear the account‚Äôs code and reset its code hash to the empty hash, however, be aware that it will not automatically clean the EOA storage.\n\nWhen changing an account‚Äôs delegation, ensure the newly delegated code is purposely designed and tested as an upgrade to the old one. To ensure safe migration between delegate contracts, namespaced storage that avoid accidental collisions following ERC-7201.\n\n|     |     |\n| --- | --- |\n|  | Updating the delegation designator may render your EOA unusable due to potential storage collisions. We recommend following similar practices to those of [writing upgradeable smart contracts](https://docs.openzeppelin.com/upgrades-plugins/writing-upgradeable). |\n\n## Using with ERC-4337\n\nThe ability to set code to execute logic on an EOA allows users to leverage ERC-4337 infrastructure to process user operations. Developers only need to combine an [`Account`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account) contract with an [`SignerERC7702`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerERC7702) to accomplish ERC-4337 compliance out of the box.\n\n### Sending a UserOp\n\nOnce your EOA is delegated to an ERC-4337 compatible account, you can send user operations through the entry point contract. The user operation includes all the necessary fields for execution, including gas limits, fees, and the actual call data to execute. The entry point will validate the operation and execute it in the context of your delegated account.\n\nSimilar to how [sending a UserOp](https://docs.openzeppelin.com/contracts/5.x/accounts#bundle_a_useroperation) is achieved for factory accounts, here‚Äôs how you can construct a UserOp for an EOA who‚Äôs delegated to an [`Account`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account) contract.\n\n```typescript hljs\nconst userOp = {\n  sender: eoa.address,\n  nonce: await entrypoint.read.getNonce([eoa.address, 0n]),\n  initCode: \"0x\" as Hex,\n  callData: '0x<CALLDATA_TO_EXECUTE_IN_THE_ACCOUNT>',\n  accountGasLimits: encodePacked(\n    [\"uint128\", \"uint128\"],\n    [\\\n      100_000n, // verificationGas\\\n      300_000n, // callGas\\\n    ]\n  ),\n  preVerificationGas: 50_000n,\n  gasFees: encodePacked(\n    [\"uint128\", \"uint128\"],\n    [\\\n      0n, // maxPriorityFeePerGas\\\n      0n, // maxFeePerGas\\\n    ]\n  ),\n  paymasterAndData: \"0x\" as Hex,\n  signature: \"0x\" as Hex,\n};\n\nconst userOpHash = await entrypoint.read.getUserOpHash([userOp]);\nuserOp.signature = await eoa.sign({ hash: userOpHash });\n\nconst userOpReceipt = await eoaClient\n  .writeContract({\n    abi: EntrypointV08Abi,\n    address: entrypoint.address,\n    authorizationList: [authorization],\n    functionName: \"handleOps\",\n    args: [[userOp], eoa.address],\n  })\n  .then((txHash) =>\n    publicClient.waitForTransactionReceipt({\n      hash: txHash,\n    })\n  );\n\nconsole.log(userOpReceipt);\n```\n\n|     |     |\n| --- | --- |\n|  | When using sponsored transaction relayers, be aware that the authorized account can cause relayers to spend gas without being reimbursed by either invalidating the authorization (increasing the account‚Äôs nonce) or by sweeping the relevant assets out of the account. Relayers may implement safeguards like requiring a bond or using a reputation system. |\n\n[‚Üê Accounts](https://docs.openzeppelin.com/contracts/5.x/accounts)\n\n[Multisig ‚Üí](https://docs.openzeppelin.com/contracts/5.x/multisig)","metadata":{"favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","ogImage":"https://docs.openzeppelin.com/_/images/social.png","ogTitle":"EOA Delegation - OpenZeppelin Docs","title":"EOA Delegation - OpenZeppelin Docs","og:title":"EOA Delegation - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","language":"en","viewport":"width=device-width, initial-scale=1.0","twitter:card":"summary","scrapeId":"5ffc1701-d5b1-4594-a42c-30245afee48b","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/eoa-delegation","url":"https://docs.openzeppelin.com/contracts/5.x/eoa-delegation","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Smart Accounts\n\nOpenZeppelin provides a simple [`Account`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account) implementation including only the basic logic to handle user operations in compliance with ERC-4337. Developers who want to build their own account can leverage it to bootstrap custom implementations.\n\nUser operations are validated using an [`AbstractSigner`](https://docs.openzeppelin.com/contracts/5.x/api/utils#AbstractSigner), which requires to implement the internal [`_rawSignatureValidation`](https://docs.openzeppelin.com/contracts/5.x/api/utils#AbstractSigner-_rawSignatureValidation-bytes32-bytes-) function, of which we offer a set of implementations to cover a wide customization range. This is the lowest-level signature validation layer and is used to wrap other validation methods like the Account‚Äôs [`validateUserOp`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account-validateUserOp-struct-PackedUserOperation-bytes32-uint256-).\n\n## Setting up an account\n\nTo setup an account, you can either start configuring it using our Wizard and selecting a predefined validation scheme, or bring your own logic and start by inheriting [`Account`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account) from scratch.\n\nOpenZeppelin Contracts Wizard\n\nMake a token with supply of 10 million What does mintable do? Make a contract for a DAO\n\nI can also edit Wizard settings directly, so from time to time I will update those based on your input.\n\nWiz here üëã. Feel free to ask any questions you have about smart contract development.\n\nAI Assistant\n\n\nAI Assistant\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nNameSymbol\n\nBase URI\n\n\n# Features\n\nMintable\n\nAuto Increment Ids\n\nBurnable\n\nPausable\n\nEnumerable\n\nURI Storage\n\n\n# Votes\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nNameURI\n\n\n# Features\n\nMintable\n\nBurnable\n\nSupply Tracking\n\nPausable\n\nUpdatable URI\n\n\n# Access Control\n\nOwnable\n\nRoles\n\nManaged\n\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\nCustodian\\*\n\n\n# Limitations\\*\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nNameSymbol\n\nPremint\n\n\n# Features\n\nMintable\n\nBurnable\n\nPausable\n\nCallback\n\nPermit\n\nFlash Minting\n\nCustodian\\*\n\n\n# Limitations\\*\n\n# Votes\n\n# Cross-Chain Bridging\n\n# Access Control\n\n# Info\n\nSecurity Contact\nLicense\n\n**\\\\* Experimental:** Some of the following features are not audited and are subject to change\n\n# Settings\n\nName\n\n# Features\n\nSignature Validation\n\nAccount Bound\n\nERC721 Holder\n\nERC1155 Holder\n\nBatched Execution\n\nModules\n\nHooked\n\n\n# Signer\n\nECDSA\n\nEOA Delegation\n\nMultisig\\*\n\nMultisig Weighted\\*\n\nP256\n\nRSA\n\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nName\n\nVoting DelayVoting Period\n\nProposal Threshold\nQuorum\n% \\#\n\nToken decimals:\n\n\nUpdatable Settings\n\nStorage\n\n\n# Votes\n\nERC20Votes\n\nERC721Votes\n\n\n# Token Clock Mode\n\nBlock Number\n\n\n1 block =\n\nseconds\n\nTimestamp\n\n\n# Timelock\n\nTimelockController\n\nCompound\n\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n# Settings\n\nName\n\n# Features\n\nPausable\n\n\n# Access Control\n\n# Upgradeability\n\n# Info\n\nSecurity Contact\nLicense\n\n```hljs -solidity grow overflow-auto p-4\n        // SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.4.0 and Community Contracts commit de17c8e\npragma solidity ^0.8.27;\n\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\nimport {ERC7739} from \"@openzeppelin/community-contracts/utils/cryptography/ERC7739.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SignerECDSA} from \"@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol\";\n\n/// @custom:oz-upgrades-unsafe-allow constructor\ncontract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSA, ERC721Holder, ERC1155Holder {\n    constructor() EIP712(\"MyAccount\", \"1\") {\n        _disableInitializers();\n    }\n\n    function initializeECDSA(address signer) public initializer {\n        _setSigner(signer);\n    }\n}\n\n\n```\n\n|     |     |\n| --- | --- |\n|  | Accounts don‚Äôt support [ERC-721](https://docs.openzeppelin.com/contracts/5.x/erc721) and [ERC-1155](https://docs.openzeppelin.com/contracts/5.x/erc1155) tokens natively since these require the receiving address to implement an acceptance check. It is recommended to inherit [ERC721Holder](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC721#ERC721Holder), [ERC1155Holder](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC1155#ERC1155Holder) to include these checks in your account. |\n\n### Selecting a signer\n\nSince the minimum requirement of [`Account`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account) is to provide an implementation of [`_rawSignatureValidation`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#AbstractSigner-_rawSignatureValidation-bytes32-bytes-), the library includes specializations of the `AbstractSigner` contract that use custom digital signature verification algorithms. Some examples that you can select from include:\n\n- [`SignerECDSA`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerECDSA): Verifies signatures produced by regular EVM Externally Owned Accounts (EOAs).\n\n- [`SignerP256`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerP256): Validates signatures using the secp256r1 curve, common for World Wide Web Consortium (W3C) standards such as FIDO keys, passkeys or secure enclaves.\n\n- [`SignerRSA`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerRSA): Verifies signatures of traditional PKI systems and X.509 certificates.\n\n- [`SignerERC7702`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerERC7702): Checks EOA signatures delegated to this signer using [EIP-7702 authorizations](https://eips.ethereum.org/EIPS/eip-7702#set-code-transaction)\n\n- [`SignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerERC7913): Verifies generalized signatures following [ERC-7913](https://eips.ethereum.org/EIPS/eip-7913).\n\n- [`SignerZKEmail`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerZKEmail): Enables email-based authentication for smart contracts using zero knowledge proofs of email authority signatures.\n\n- [`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913): Allows using multiple ERC-7913 signers with a threshold-based signature verification system.\n\n- [`MultiSignerERC7913Weighted`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913Weighted): Overrides the threshold mechanism of [`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#MultiSignerERC7913), offering different weights per signer.\n\n\n|     |     |\n| --- | --- |\n|  | Given [`SignerERC7913`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignerERC7913) provides a generalized standard for signature validation, you don‚Äôt need to implement your own [`AbstractSigner`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#AbstractSigner) for different signature schemes, consider bringing your own ERC-7913 verifier instead. |\n\n#### Accounts factory\n\nThe first time you send an user operation, your account will be created deterministically (i.e. its code and address can be predicted) using the the `initCode` field in the UserOperation. This field contains both the address of a smart contract (the factory) and the data required to call it and create your smart account.\n\nSuggestively, you can create your own account factory using the [Clones library](https://docs.openzeppelin.com/contracts/5.x/api/proxy#Clones), taking advantage of decreased deployment costs and account address predictability.\n\n```solidity hljs\n// contracts/MyFactoryAccount.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev A factory contract to create accounts on demand.\n */\ncontract MyFactoryAccount {\n    using Clones for address;\n    using Address for address;\n\n    address private immutable _impl;\n\n    constructor(address impl_) {\n        require(impl_.code.length > 0);\n        _impl = impl_;\n    }\n\n    /// @dev Predict the address of the account\n    function predictAddress(bytes calldata callData) public view returns (address) {\n        return _impl.predictDeterministicAddress(keccak256(callData), address(this));\n    }\n\n    /// @dev Create clone accounts on demand\n    function cloneAndInitialize(bytes calldata callData) public returns (address) {\n        address predicted = predictAddress(callData);\n        if (predicted.code.length == 0) {\n            _impl.cloneDeterministic(keccak256(callData));\n            predicted.functionCall(callData);\n        }\n        return predicted;\n    }\n}\n```\n\nAccount factories should be carefully implemented to ensure the account address is deterministically tied to the initial owners. This prevents frontrunning attacks where a malicious actor could deploy the account with their own owners before the intended owner does. The factory should include the owner‚Äôs address in the salt used for address calculation.\n\n#### Handling initialization\n\nMost smart accounts are deployed by a factory, the best practice is to create [minimal clones](https://docs.openzeppelin.com/contracts/5.x/api/proxy#minimal_clones) of initializable contracts. These signer implementations provide an initializable design by default so that the factory can interact with the account to set it up right after deployment in a single transaction.\n\n```solidity hljs\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {SignerECDSA} from \"@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol\";\n\ncontract MyAccount is Initializable, Account, SignerECDSA, ... {\n    // ...\n\n    function initializeECDSA(address signer) public initializer {\n        _setSigner(signer);\n    }\n}\n```\n\nNote that some account implementations may be deployed directly and therefore, won‚Äôt require a factory.\n\n|     |     |\n| --- | --- |\n|  | Leaving an account uninitialized may leave it unusable since no public key was associated with it. |\n\n### Signature validation\n\nRegularly, accounts implement [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) to enable smart contract signature verification given its wide adoption. To be compliant means that smart contract exposes an [`isValidSignature(bytes32 hash, bytes memory signature)`](https://docs.openzeppelin.com/contracts/5.x/api/interfaces#IERC1271-isValidSignature-bytes32-bytes-) method that returns `0x1626ba7e` to identify whether the signature is valid.\n\nThe benefit of this standard is that it allows to receive any format of `signature` for a given `hash`. This generalized mechanism fits very well with the account abstraction principle of _bringing your own validation mechanism_.\n\nThis is how you enable ERC-1271 using an [`AbstractSigner`](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#AbstractSigner):\n\n```solidity hljs\nfunction isValidSignature(bytes32 hash, bytes calldata signature) public view override returns (bytes4) {\n    return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);\n}\n```\n\n|     |     |\n| --- | --- |\n|  | We recommend using [ERC7739](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#ERC7739) to avoid replayability across accounts. This defensive rehashing mechanism that prevents signatures for this account to be replayed in another account controlled by the same signer. See [ERC-7739 signatures](https://docs.openzeppelin.com/contracts/5.x/accounts#erc_7739_signatures). |\n\n### Batched execution\n\nBatched execution allows accounts to execute multiple calls in a single transaction, which is particularly useful for bundling operations that need to be atomic. This is especially valuable in the context of account abstraction where you want to minimize the number of user operations and associated gas costs. [`ERC-7821`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC7821) standard provides a minimal interface for batched execution.\n\nThe library implementation supports a single batch mode ( `0x01000000000000000000`) and allows accounts to execute multiple calls atomically. The standard includes access control through the [`_erc7821AuthorizedExecutor`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC7821-_erc7821AuthorizedExecutor-address-bytes32-bytes-) function, which by default only allows the contract itself to execute batches.\n\nHere‚Äôs an example of how to use batched execution using EIP-7702:\n\n```solidity hljs\nimport {Account} from \"@openzeppelin/community-contracts/account/Account.sol\";\nimport {ERC7821} from \"@openzeppelin/community-contracts/account/extensions/draft-ERC7821.sol\";\nimport {SignerERC7702} from \"@openzeppelin/community-contracts/utils/cryptography/SignerERC7702.sol\";\n\ncontract MyAccount is Account, SignerERC7702, ERC7821 {\n    // Override to allow the entrypoint to execute batches\n    function _erc7821AuthorizedExecutor(\n        address caller,\n        bytes32 mode,\n        bytes calldata executionData\n    ) internal view virtual override returns (bool) {\n        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);\n    }\n}\n```\n\nThe batched execution data follows a specific format that includes the calls to be executed. This format follows the same format as [ERC-7579 execution](https://eips.ethereum.org/EIPS/eip-7579#execution-behavior) but only supports `0x01` call type (i.e. batched `call`) and default execution type (i.e. reverts if at least one subcall does).\n\nTo encode an ERC-7821 batch, you can use [viem](https://viem.sh/)'s utilities:\n\n```typescript hljs\n// CALL_TYPE_BATCH, EXEC_TYPE_DEFAULT, ..., selector, payload\nconst mode = encodePacked(\n  [\"bytes1\", \"bytes1\", \"bytes4\", \"bytes4\", \"bytes22\"],\n  [\"0x01\", \"0x00\", \"0x00000000\", \"0x00000000\", \"0x00000000000000000000000000000000000000000000\"]\n);\n\nconst entries = [\\\n  {\\\n    target: \"0x000...0001\",\\\n    value: 0n,\\\n    data: \"0x000...000\",\\\n  },\\\n  {\\\n    target: \"0x000...0002\",\\\n    value: 0n,\\\n    data: \"0x000...000\",\\\n  }\\\n];\n\nconst batch = encodeAbiParameters(\n  [parseAbiParameter(\"(address,uint256,bytes)[]\")],\n  [\\\n    entries.map<[Address, bigint, Hex]>((entry) =>\\\n      [entry.target, entry.value ?? 0n, entry.data ?? \"0x\"]\\\n    ),\\\n  ]\n);\n\nconst userOpData = encodeFunctionData({\n    abi: account.abi,\n    functionName: \"execute\",\n    args: [mode, batch]\n});\n```\n\n## Bundle a `UserOperation`\n\n[UserOperations](https://docs.openzeppelin.com/contracts/5.x/account-abstraction#useroperation) are a powerful abstraction layer that enable more sophisticated transaction capabilities compared to traditional Ethereum transactions. To get started, you‚Äôll need to an account, which you can get by [deploying a factory](https://docs.openzeppelin.com/contracts/5.x/accounts#accounts_factory) for your implementation.\n\n### Preparing a UserOp\n\nA UserOperation is a struct that contains all the necessary information for the EntryPoint to execute your transaction. You‚Äôll need the `sender`, `nonce`, `accountGasLimits` and `callData` fields to construct a `PackedUserOperation` that can be signed later (to populate the `signature` field).\n\n|     |     |\n| --- | --- |\n|  | Specify `paymasterAndData` with the address of a paymaster contract concatenated to `data` that will be passed to the paymaster‚Äôs validatePaymasterUserOp function to support sponsorship as part of your user operation. |\n\nHere‚Äôs how to prepare one using [viem](https://viem.sh/):\n\n```typescript hljs\nimport { getContract, createWalletClient, http, Hex } from 'viem';\n\nconst walletClient = createWalletClient({\n  account, // See Viem's `privateKeyToAccount`\n  chain, // import { ... } from 'viem/chains';\n  transport: http(),\n})\n\nconst entrypoint = getContract({\n  abi: [/* ENTRYPOINT ABI */],\n  address: '0x<ENTRYPOINT_ADDRESS>',\n  client: walletClient,\n});\n\nconst userOp = {\n  sender: '0x<YOUR_ACCOUNT_ADDRESS>',\n  nonce: await entrypoint.read.getNonce([sender, 0n]),\n  initCode: \"0x\" as Hex,\n  callData: '0x<CALLDATA_TO_EXECUTE_IN_THE_ACCOUNT>',\n  accountGasLimits: encodePacked(\n    [\"uint128\", \"uint128\"],\n    [\\\n      100_000n, // verificationGasLimit\\\n      300_000n, // callGasLimit\\\n    ]\n  ),\n  preVerificationGas: 50_000n,\n  gasFees: encodePacked(\n    [\"uint128\", \"uint128\"],\n    [\\\n      0n, // maxPriorityFeePerGas\\\n      0n, // maxFeePerGas\\\n    ]\n  ),\n  paymasterAndData: \"0x\" as Hex,\n  signature: \"0x\" as Hex,\n};\n```\n\nIn case your account hasn‚Äôt been deployed yet, make sure to provide the `initCode` field as `abi.encodePacked(factory, factoryData)` to deploy the account within the same UserOp:\n\n```typescript hljs\nconst deployed = await publicClient.getCode({ address: predictedAddress });\n\nif (!deployed) {\n  userOp.initCode = encodePacked(\n    [\"address\", \"bytes\"],\n    [\\\n      '0x<ACCOUNT_FACTORY_ADDRESS>',\\\n      encodeFunctionData({\\\n        abi: [/* ACCOUNT ABI */],\\\n        functionName: \"<FUNCTION NAME>\",\\\n        args: [...],\\\n      }),\\\n    ]\n  );\n}\n```\n\n#### Estimating gas\n\nTo calculate gas parameters of a `UserOperation`, developers should carefully consider the following fields:\n\n- `verificationGasLimit`: This covers the gas costs for signature verification, paymaster validation (if used), and account validation logic. While a typical value is around 100,000 gas units, this can vary significantly based on the complexity of your signature validation scheme in both the account and paymaster contracts.\n\n- `callGasLimit`: This parameter accounts for the actual execution of your account‚Äôs logic. It‚Äôs recommended to use `eth_estimateGas` for each subcall and add additional buffer for computational overhead.\n\n- `preVerificationGas`: This compensates for the EntryPoint‚Äôs execution overhead. While 50,000 gas is a reasonable starting point, you may need to increase this value based on your UserOperation‚Äôs size and specific bundler requirements.\n\n\n|     |     |\n| --- | --- |\n|  | The `maxFeePerGas` and `maxPriorityFeePerGas` values are typically provided by your bundler service, either through their SDK or a custom RPC method. |\n\n|     |     |\n| --- | --- |\n|  | A penalty of 10% ( `UNUSED_GAS_PENALTY_PERCENT`) is applied on the amounts of `callGasLimit` and `paymasterPostOpGasLimit` gas that remains unused if the amount of remaining unused gas is greater than or equal to 40,000 ( `PENALTY_GAS_THRESHOLD`). |\n\n### Signing the UserOp\n\nTo sign a UserOperation, you‚Äôll need to first calculate its hash as an EIP-712 typed data structure using the EntryPoint‚Äôs domain, then sign this hash using your account‚Äôs signature scheme, and finally encode the resulting signature in the format that your account contract expects for verification.\n\n```typescript hljs\nimport { signTypedData } from 'viem/actions';\n\n// EntryPoint v0.8 EIP-712 domain\nconst domain = {\n  name: 'ERC4337',\n  version: '1',\n  chainId: 1, // Your target chain ID\n  verifyingContract: '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108', // v08\n};\n\n// EIP-712 types for PackedUserOperation\nconst types = {\n  PackedUserOperation: [\\\n    { name: 'sender', type: 'address' },\\\n    { name: 'nonce', type: 'uint256' },\\\n    { name: 'initCode', type: 'bytes' },\\\n    { name: 'callData', type: 'bytes' },\\\n    { name: 'accountGasLimits', type: 'bytes32' },\\\n    { name: 'preVerificationGas', type: 'uint256' },\\\n    { name: 'gasFees', type: 'bytes32' },\\\n    { name: 'paymasterAndData', type: 'bytes' },\\\n  ],\n} as const;\n\n// Sign the UserOperation using EIP-712\nuserOp.signature = await eoa.signTypedData({\n  domain,\n  types,\n  primaryType: 'PackedUserOperation',\n  message: {\n    sender: userOp.sender,\n    nonce: userOp.nonce,\n    initCode: userOp.initCode,\n    callData: userOp.callData,\n    accountGasLimits: userOp.accountGasLimits,\n    preVerificationGas: userOp.preVerificationGas,\n    gasFees: userOp.gasFees,\n    paymasterAndData: userOp.paymasterAndData,\n  },\n});\n```\n\nAlternatively, developers can get the raw user operation hash by using the Entrypoint‚Äôs `getUserOpHash` function:\n\n```typescript hljs\nconst userOpHash = await entrypoint.read.getUserOpHash([userOp]);\nuserOp.signature = await eoa.sign({ hash: userOpHash });\n```\n\n|     |     |\n| --- | --- |\n|  | Using `getUserOpHash` directly may provide a poorer user experience as users see an opaque hash rather than structured transaction data. In many cases, offchain signers won‚Äôt have an option to sign a raw hash. |\n\n### Sending the UserOp\n\nFinally, to send the user operation you can call `handleOps` on the Entrypoint contract and set yourself as the `beneficiary`.\n\n```typescript hljs\n// Send the UserOperation\nconst userOpReceipt = await walletClient\n  .writeContract({\n    abi: [/* ENTRYPOINT ABI */],\n    address: '0x<ENTRYPOINT_ADDRESS>',\n    functionName: \"handleOps\",\n    args: [[userOp], eoa.address],\n  })\n  .then((txHash) =>\n    publicClient.waitForTransactionReceipt({\n      hash: txHash,\n    })\n  );\n\n// Print receipt\nconsole.log(userOpReceipt);\n```\n\n|     |     |\n| --- | --- |\n|  | Since you‚Äôre bundling your user operations yourself, you can safely specify `preVerificationGas` and `maxFeePerGas` in 0. |\n\n### Using a Bundler\n\nFor better reliability, consider using a bundler service. Bundlers provide several key benefits: they automatically handle gas estimation, manage transaction ordering, support bundling multiple operations together, and generally offer higher transaction success rates compared to self-bundling.\n\n## Further notes\n\n### ERC-7739 Signatures\n\nA common security practice to prevent user operation [replayability across smart contract accounts controlled by the same private key](https://mirror.xyz/curiousapple.eth/pFqAdW2LiJ-6S4sg_u1z08k4vK6BCJ33LcyXpnNb8yU) (i.e. multiple accounts for the same signer) is to link the signature to the `address` and `chainId` of the account. This can be done by asking the user to sign a hash that includes these values.\n\nThe problem with this approach is that the user might be prompted by the wallet provider to sign an [obfuscated message](https://x.com/howydev/status/1780353754333634738), which is a phishing vector that may lead to a user losing its assets.\n\nTo prevent this, developers may use [`ERC7739Signer`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC7739Signer), a utility that implements [`IERC1271`](https://docs.openzeppelin.com/contracts/5.x/api/interfaces#IERC1271) for smart contract signatures with a defensive rehashing mechanism based on a [nested EIP-712 approach](https://github.com/frangio/eip712-wrapper-for-eip1271) to wrap the signature request in a context where there‚Äôs clearer information for the end user.\n\n### EIP-7702 Delegation\n\n[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) lets EOAs delegate to smart contracts while keeping their original signing key. This creates a hybrid account that works like an EOA for signing but has smart contract features. Protocols don‚Äôt need major changes to support EIP-7702 since they already handle both EOAs and smart contracts (see [SignatureChecker](https://docs.openzeppelin.com/contracts/5.x/api/utils/cryptography#SignatureChecker)).\n\nThe signature verification stays compatible: delegated EOAs are treated as contracts using ERC-1271, making it easy to redelegate to a contract with ERC-1271 support with little overhead by reusing the validation mechanism of the account.\n\n|     |     |\n| --- | --- |\n|  | Learn more about delegating to an ERC-7702 account in our [EOA Delegation](https://docs.openzeppelin.com/contracts/5.x/eoa-delegation) section. |\n\n### ERC-7579 Modules\n\nSmart accounts have evolved to embrace modularity as a design principle, with popular implementations like [Safe, Pimlico, Rhinestone, Etherspot and many others](https://erc7579.com/#supporters) agreeing on ERC-7579 as the standard for module interoperability. This standardization enables accounts to extend their functionality through external contracts while maintaining compatibility across different implementations.\n\nOpenZeppelin Contracts provides both the building blocks for creating ERC-7579-compliant modules and an [`AccountERC7579`](https://docs.openzeppelin.com/contracts/5.x/api/account#AccountERC7579) implementation that supports installing and managing these modules.\n\n|     |     |\n| --- | --- |\n|  | Learn more in our [account modules](https://docs.openzeppelin.com/community-contracts/0.0.1/account-modules) section. |\n\n[‚Üê Account Abstraction](https://docs.openzeppelin.com/contracts/5.x/account-abstraction)\n\n[EOA Delegation ‚Üí](https://docs.openzeppelin.com/contracts/5.x/eoa-delegation)","metadata":{"ogTitle":"Smart Accounts - OpenZeppelin Docs","og:image":"https://docs.openzeppelin.com/_/images/social.png","language":"en","twitter:card":"summary","og:title":"Smart Accounts - OpenZeppelin Docs","title":"Smart Accounts - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","favicon":"https://wizard.openzeppelin.com/favicon.png","viewport":["width=device-width, initial-scale=1.0","width=device-width,initial-scale=1"],"scrapeId":"b6e49eaa-17ad-4884-ae1e-4f4d55f25e57","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/accounts","url":"https://docs.openzeppelin.com/contracts/5.x/accounts","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# ERC-4626\n\n[ERC-4626](https://eips.ethereum.org/EIPS/eip-4626) is an extension of [ERC-20](https://docs.openzeppelin.com/contracts/5.x/erc20) that proposes a standard interface for token vaults. This standard interface can be used by widely different contracts (including lending markets, aggregators, and intrinsically interest bearing tokens), which brings a number of subtleties. Navigating these potential issues is essential to implementing a compliant and composable token vault.\n\nWe provide a base implementation of ERC-4626 that includes a simple vault. This contract is designed in a way that allows developers to easily re-configure the vault‚Äôs behavior, with minimal overrides, while staying compliant. In this guide, we will discuss some security considerations that affect ERC-4626. We will also discuss common customizations of the vault.\n\n## Security concern: Inflation attack\n\n### Visualizing the vault\n\nIn exchange for the assets deposited into an ERC-4626 vault, a user receives shares. These shares can later be burned to redeem the corresponding underlying assets. The number of shares a user gets depends on the amount of assets they put in and on the exchange rate of the vault. This exchange rate is defined by the current liquidity held by the vault.\n\n- If a vault has 100 tokens to back 200 shares, then each share is worth 0.5 assets.\n\n- If a vault has 200 tokens to back 100 shares, then each share is worth 2.0 assets.\n\n\nIn other words, the exchange rate can be defined as the slope of the line that passes through the origin and the current number of assets and shares in the vault. Deposits and withdrawals move the vault in this line.\n\n![Exchange rates in linear scale](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-rate-linear.png)\n\nWhen plotted in log-log scale, the rate is defined similarly, but appears differently (because the point (0,0) is infinitely far away). Rates are represented by \"diagonal\" lines with different offsets.\n\n![Exchange rates in logarithmic scale](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-rate-loglog.png)\n\nIn such a representation, widely different rates can be clearly visible in the same graph. This wouldn‚Äôt be the case in linear scale.\n\n![More exchange rates in logarithmic scale](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-rate-loglogext.png)\n\n### The attack\n\nWhen depositing tokens, the number of shares a user gets is rounded towards zero. This rounding takes away value from the user in favor of the vault (i.e. in favor of all the current shareholders). This rounding is often negligible because of the amount at stake. If you deposit 1e9 shares worth of tokens, the rounding will have you lose at most 0.0000001% of your deposit. However if you deposit 10 shares worth of tokens, you could lose 10% of your deposit. Even worse, if you deposit <1 share worth of tokens, then you get 0 shares, and you basically made a donation.\n\nFor a given amount of assets, the more shares you receive the safer you are. If you want to limit your losses to at most 1%, you need to receive at least 100 shares.\n\n![Depositing assets](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-deposit.png)\n\nIn the figure we can see that for a given deposit of 500 assets, the number of shares we get and the corresponding rounding losses depend on the exchange rate. If the exchange rate is that of the orange curve, we are getting less than a share, so we lose 100% of our deposit. However, if the exchange rate is that of the green curve, we get 5000 shares, which limits our rounding losses to at most 0.02%.\n\n![Minting shares](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-mint.png)\n\nSymmetrically, if we focus on limiting our losses to a maximum of 0.5%, we need to get at least 200 shares. With the green exchange rate that requires just 20 tokens, but with the orange rate that requires 200000 tokens.\n\nWe can clearly see that the blue and green curves correspond to vaults that are safer than the yellow and orange curves.\n\nThe idea of an inflation attack is that an attacker can donate assets to the vault to move the rate curve to the right, and make the vault unsafe.\n\n![Inflation attack without protection](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-attack.png)\n\nFigure 6 shows how an attacker can manipulate the rate of an empty vault. First the attacker must deposit a small amount of tokens (1 token) and follow up with a donation of 1e5 tokens directly to the vault to move the exchange rate \"right\". This puts the vault in a state where any deposit smaller than 1e5 would be completely lost to the vault. Given that the attacker is the only shareholder (from their donation), the attacker would steal all the tokens deposited.\n\nAn attacker would typically wait for a user to do the first deposit into the vault, and would frontrun that operation with the attack described above. The risk is low, and the size of the \"donation\" required to manipulate the vault is equivalent to the size of the deposit that is being attacked.\n\nIn math that gives:\n\n- a0 the attacker deposit\n\n- a1 the attacker donation\n\n- u the user deposit\n\n\n|  | Assets | Shares | Rate |\n| --- | --- | --- | --- |\n| initial | 0 | 0 | - |\n| after attacker‚Äôs deposit | a0 | a0 | 1 |\n| after attacker‚Äôs donation | a0+a1 | a0 | a0a0+a1 |\n\nThis means a deposit of u will give u√óa0a0+a1 shares.\n\nFor the attacker to dilute that deposit to 0 shares, causing the user to lose all its deposit, it must ensure that\n\nu√óa0a0+a1<1‚ü∫u<1+a1a0\n\nUsing a0=1 and a1=u is enough. So the attacker only needs u+1 assets to perform a successful attack.\n\nIt is easy to generalize the above results to scenarios where the attacker is going after a smaller fraction of the user‚Äôs deposit. In order to target un, the user needs to suffer rounding of a similar fraction, which means the user must receive at most n shares. This results in:\n\nu√óa0a0+a1<n‚ü∫un<1+a1a0\n\nIn this scenario, the attack is n times less powerful (in how much it is stealing) and costs n times less to execute. In both cases, the amount of funds the attacker needs to commit is equivalent to its potential earnings.\n\n### Defending with a virtual offset\n\nThe defense we propose is based on the approach used in [YieldBox](https://github.com/boringcrypto/YieldBox). It consists of two parts:\n\n- Use an offset between the \"precision\" of the representation of shares and assets. Said otherwise, we use more decimal places to represent the shares than the underlying token does to represent the assets.\n\n- Include virtual shares and virtual assets in the exchange rate computation. These virtual assets enforce the conversion rate when the vault is empty.\n\n\nThese two parts work together in enforcing the security of the vault. First, the increased precision corresponds to a high rate, which we saw is safer as it reduces the rounding error when computing the amount of shares. Second, the virtual assets and shares (in addition to simplifying a lot of the computations) capture part of the donation, making it unprofitable for a developer to perform an attack.\n\nFollowing the previous math definitions, we have:\n\n- Œ¥ the vault offset\n\n- a0 the attacker deposit\n\n- a1 the attacker donation\n\n- u the user deposit\n\n\n|  | Assets | Shares | Rate |\n| --- | --- | --- | --- |\n| initial | 1 | 10Œ¥ | 10Œ¥ |\n| after attacker‚Äôs deposit | 1+a0 | 10Œ¥√ó(1+a0) | 10Œ¥ |\n| after attacker‚Äôs donation | 1+a0+a1 | 10Œ¥√ó(1+a0) | 10Œ¥√ó1+a01+a0+a1 |\n\nOne important thing to note is that the attacker only owns a fraction a01+a0 of the shares, so when doing the donation, he will only be able to recover that fraction a1√óa01+a0 of the donation. The remaining a11+a0 are captured by the vault.\n\nloss=a11+a0\n\nWhen the user deposits u, he receives\n\n10Œ¥√óu√ó1+a01+a0+a1\n\nFor the attacker to dilute that deposit to 0 shares, causing the user to lose all its deposit, it must ensure that\n\n10Œ¥√óu√ó1+a01+a0+a1<1\n\n‚ü∫10Œ¥√óu<1+a0+a11+a0\n\n‚ü∫10Œ¥√óu<1+a11+a0\n\n‚ü∫10Œ¥√óu‚â§loss\n\n- If the offset is 0, the attacker loss is at least equal to the user‚Äôs deposit.\n\n- If the offset is greater than 0, the attacker will have to suffer losses that are orders of magnitude bigger than the amount of value that can hypothetically be stolen from the user.\n\n\nThis shows that even with an offset of 0, the virtual shares and assets make this attack non profitable for the attacker. Bigger offsets increase the security even further by making any attack on the user extremely wasteful.\n\nThe following figure shows how the offset impacts the initial rate and limits the ability of an attacker with limited funds to inflate it effectively.\n\n![Inflation attack without offset=3](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-attack-3a.png)\n\nŒ¥=3, a0=1, a1=105\n\n![Inflation attack without offset=3 and an attacker deposit that limits its losses](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-attack-3b.png)\n\nŒ¥=3, a0=100, a1=105\n\n![Inflation attack without offset=6](https://docs.openzeppelin.com/contracts/5.x/_images/erc4626-attack-6.png)\n\nŒ¥=6, a0=1, a1=105\n\n## Custom behavior: Adding fees to the vault\n\nIn an ERC-4626 vaults, fees can be captured during the deposit/mint and/or during the withdraw/redeem steps. In both cases it is essential to remain compliant with the ERC-4626 requirements with regard to the preview functions.\n\nFor example, if calling `deposit(100, receiver)`, the caller should deposit exactly 100 underlying tokens, including fees, and the receiver should receive a number of shares that matches the value returned by `previewDeposit(100)`. Similarly, `previewMint` should account for the fees that the user will have to pay on top of share‚Äôs cost.\n\nAs for the `Deposit` event, while this is less clear in the EIP spec itself, there seems to be consensus that it should include the number of assets paid for by the user, including the fees.\n\nOn the other hand, when withdrawing assets, the number given by the user should correspond to what he receives. Any fees should be added to the quote (in shares) performed by `previewWithdraw`.\n\nThe `Withdraw` event should include the number of shares the user burns (including fees) and the number of assets the user actually receives (after fees are deducted).\n\nThe consequence of this design is that both the `Deposit` and `Withdraw` events will describe two exchange rates. The spread between the \"Buy-in\" and the \"Exit\" prices correspond to the fees taken by the vault.\n\nThe following example describes how fees proportional to the deposited/withdrawn amount can be implemented:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC4626} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/// @dev ERC-4626 vault with entry/exit fees expressed in https://en.wikipedia.org/wiki/Basis_point[basis point (bp)].\n///\n/// NOTE: The contract charges fees in terms of assets, not shares. This means that the fees are calculated based on the\n/// amount of assets that are being deposited or withdrawn, and not based on the amount of shares that are being minted or\n/// redeemed. This is an opinionated design decision that should be taken into account when integrating this contract.\n///\n/// WARNING: This contract has not been audited and shouldn't be considered production ready. Consider using it with caution.\nabstract contract ERC4626Fees is ERC4626 {\n    using Math for uint256;\n\n    uint256 private constant _BASIS_POINT_SCALE = 1e4;\n\n    // === Overrides ===\n\n    /// @dev Preview taking an entry fee on deposit. See {IERC4626-previewDeposit}.\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        uint256 fee = _feeOnTotal(assets, _entryFeeBasisPoints());\n        return super.previewDeposit(assets - fee);\n    }\n\n    /// @dev Preview adding an entry fee on mint. See {IERC4626-previewMint}.\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        uint256 assets = super.previewMint(shares);\n        return assets + _feeOnRaw(assets, _entryFeeBasisPoints());\n    }\n\n    /// @dev Preview adding an exit fee on withdraw. See {IERC4626-previewWithdraw}.\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        uint256 fee = _feeOnRaw(assets, _exitFeeBasisPoints());\n        return super.previewWithdraw(assets + fee);\n    }\n\n    /// @dev Preview taking an exit fee on redeem. See {IERC4626-previewRedeem}.\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        uint256 assets = super.previewRedeem(shares);\n        return assets - _feeOnTotal(assets, _exitFeeBasisPoints());\n    }\n\n    /// @dev Send entry fee to {_entryFeeRecipient}. See {IERC4626-_deposit}.\n    function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual override {\n        uint256 fee = _feeOnTotal(assets, _entryFeeBasisPoints());\n        address recipient = _entryFeeRecipient();\n\n        super._deposit(caller, receiver, assets, shares);\n\n        if (fee > 0 && recipient != address(this)) {\n            SafeERC20.safeTransfer(IERC20(asset()), recipient, fee);\n        }\n    }\n\n    /// @dev Send exit fee to {_exitFeeRecipient}. See {IERC4626-_deposit}.\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual override {\n        uint256 fee = _feeOnRaw(assets, _exitFeeBasisPoints());\n        address recipient = _exitFeeRecipient();\n\n        super._withdraw(caller, receiver, owner, assets, shares);\n\n        if (fee > 0 && recipient != address(this)) {\n            SafeERC20.safeTransfer(IERC20(asset()), recipient, fee);\n        }\n    }\n\n    // === Fee configuration ===\n\n    function _entryFeeBasisPoints() internal view virtual returns (uint256) {\n        return 0; // replace with e.g. 100 for 1%\n    }\n\n    function _exitFeeBasisPoints() internal view virtual returns (uint256) {\n        return 0; // replace with e.g. 100 for 1%\n    }\n\n    function _entryFeeRecipient() internal view virtual returns (address) {\n        return address(0); // replace with e.g. a treasury address\n    }\n\n    function _exitFeeRecipient() internal view virtual returns (address) {\n        return address(0); // replace with e.g. a treasury address\n    }\n\n    // === Fee operations ===\n\n    /// @dev Calculates the fees that should be added to an amount `assets` that does not already include fees.\n    /// Used in {IERC4626-mint} and {IERC4626-withdraw} operations.\n    function _feeOnRaw(uint256 assets, uint256 feeBasisPoints) private pure returns (uint256) {\n        return assets.mulDiv(feeBasisPoints, _BASIS_POINT_SCALE, Math.Rounding.Ceil);\n    }\n\n    /// @dev Calculates the fee part of an amount `assets` that already includes fees.\n    /// Used in {IERC4626-deposit} and {IERC4626-redeem} operations.\n    function _feeOnTotal(uint256 assets, uint256 feeBasisPoints) private pure returns (uint256) {\n        return assets.mulDiv(feeBasisPoints, feeBasisPoints + _BASIS_POINT_SCALE, Math.Rounding.Ceil);\n    }\n}\n```\n\n[‚Üê ERC-1155](https://docs.openzeppelin.com/contracts/5.x/erc1155)\n\n[ERC-6909 ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc6909)","metadata":{"title":"ERC-4626 - OpenZeppelin Docs","twitter:card":"summary","ogTitle":"ERC-4626 - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","og:image":"https://docs.openzeppelin.com/_/images/social.png","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","viewport":"width=device-width, initial-scale=1.0","language":"en","og:title":"ERC-4626 - OpenZeppelin Docs","scrapeId":"42b5a035-74b3-45d7-8978-cbeb120a5c6a","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc4626","url":"https://docs.openzeppelin.com/contracts/5.x/erc4626","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Account Abstraction\n\nUnlike Externally Owned Accounts (EOAs), smart contracts may contain arbitrary verification logic based on authentication mechanisms different to Ethereum‚Äôs native [ECDSA](https://docs.openzeppelin.com/contracts/5.x/api/utils#ECDSA) and have execution advantages such as batching or gas sponsorship. To leverage these properties of smart contracts, the community has widely adopted [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337), a standard to process user operations through an alternative mempool.\n\nThe library provides multiple contracts for Account Abstraction following this standard as it enables more flexible and user-friendly interactions with applications. Account Abstraction use cases include wallets in novel contexts (e.g. embedded wallets), more granular configuration of accounts, and recovery mechanisms.\n\n## ERC-4337 Overview\n\nThe ERC-4337 is a detailed specification of how to implement the necessary logic to handle operations without making changes to the protocol level (i.e. the rules of the blockchain itself). This specification defines the following components:\n\n### UserOperation\n\nA `UserOperation` is a higher-layer pseudo-transaction object that represents the intent of the account. This shares some similarities with regular EVM transactions like the concept of `gasFees` or `callData` but includes fields that enable new capabilities.\n\n```solidity hljs\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode; // concatenation of factory address and factoryData (or empty)\n    bytes callData;\n    bytes32 accountGasLimits; // concatenation of verificationGas (16 bytes) and callGas (16 bytes)\n    uint256 preVerificationGas;\n    bytes32 gasFees; // concatenation of maxPriorityFee (16 bytes) and maxFeePerGas (16 bytes)\n    bytes paymasterAndData; // concatenation of paymaster fields (or empty)\n    bytes signature;\n}\n```\n\nThis process of bundling user operations involves several costs that the bundler must cover, including base transaction fees, calldata serialization, entrypoint execution, and paymaster context costs. To compensate for these expenses, bundlers use the `preVerificationGas` and `gasFees` fields to charge users appropriately.\n\n|     |     |\n| --- | --- |\n|  | Estimating `preVerificationGas` is not standardized as it varies based on network conditions such as gas prices and the size of the operation bundle. |\n\n|     |     |\n| --- | --- |\n|  | Use [`ERC4337Utils`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC4337Utils) to manipulate the `UserOperation` struct and other ERC-4337 related values. |\n\n### Entrypoint\n\nEach `UserOperation` is executed through a contract known as the [`EntryPoint`](https://etherscan.io/address/0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108#code). This contract is a singleton deployed across multiple networks at the same address although other custom implementations may be used.\n\nThe Entrypoint contracts is considered a trusted entity by the account.\n\n### Bundlers\n\nThe bundler is a piece of _offchain_ infrastructure that is in charge of processing an alternative mempool of user operations. Bundlers themselves call the Entrypoint contract‚Äôs `handleOps` function with an array of UserOperations that are executed and included in a block.\n\nDuring the process, the bundler pays for the gas of executing the transaction and gets refunded during the execution phase of the Entrypoint contract.\n\n```solidity hljs\n/// @dev Process `userOps` and `beneficiary` receives all\n/// the gas fees collected during the bundle execution.\nfunction handleOps(\n    PackedUserOperation[] calldata ops,\n    address payable beneficiary\n) external { ... }\n```\n\n### Account Contract\n\nThe Account Contract is a smart contract that implements the logic required to validate a `UserOperation` in the context of ERC-4337. Any smart contract account should conform with the `IAccount` interface to validate operations.\n\n```solidity hljs\ninterface IAccount {\n    function validateUserOp(PackedUserOperation calldata, bytes32, uint256) external returns (uint256 validationData);\n}\n```\n\nSimilarly, an Account should have a way to execute these operations by either handling arbitrary calldata on its `fallback` or implementing the `IAccountExecute` interface:\n\n```solidity hljs\ninterface IAccountExecute {\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external;\n}\n```\n\n|     |     |\n| --- | --- |\n|  | The `IAccountExecute` interface is optional. Developers might want to use [`ERC-7821`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC7821) for a minimal batched execution interface or rely on ERC-7579 or any other execution logic. |\n\nTo build your own account, see [accounts](https://docs.openzeppelin.com/contracts/5.x/accounts).\n\n### Factory Contract\n\nThe smart contract accounts are created by a Factory contract defined by the Account developer. This factory receives arbitrary bytes as `initData` and returns an `address` where the logic of the account is deployed.\n\nTo build your own factory, see [account factories](https://docs.openzeppelin.com/contracts/5.x/accounts#accounts_factory).\n\n### Paymaster Contract\n\nA Paymaster is an optional entity that can sponsor gas fees for Accounts, or allow them to pay for those fees in ERC-20 instead of native currency. This abstracts gas away of the user experience in the same way that computational costs of cloud servers are abstracted away from end-users.\n\nTo build your own paymaster, see [paymasters](https://docs.openzeppelin.com/community-contracts/0.0.1/paymasters).\n\n## Further notes\n\n### ERC-7562 Validation Rules\n\nTo process a bundle of `UserOperations`, bundlers call [`validateUserOp`](https://docs.openzeppelin.com/contracts/5.x/api/account#Account-validateUserOp-struct-PackedUserOperation-bytes32-uint256-) on each operation sender to check whether the operation can be executed. However, the bundler has no guarantee that the state of the blockchain will remain the same after the validation phase. To overcome this problem, [ERC-7562](https://eips.ethereum.org/EIPS/eip-7562) proposes a set of limitations to EVM code so that bundlers (or node operators) are protected from unexpected state changes.\n\nThese rules outline the requirements for operations to be processed by the canonical mempool.\n\nAccounts can access its own storage during the validation phase, they might easily violate ERC-7562 storage access rules in undirect ways. For example, most accounts access their public keys from storage when validating a signature, limiting the ability of having accounts that validate operations for other accounts (e.g. via ERC-1271)\n\n|     |     |\n| --- | --- |\n|  | Although any Account that breaks such rules may still be processed by a private bundler, developers should keep in mind the centralization tradeoffs of relying on private infrastructure instead of _permissionless_ execution. |\n\n[‚Üê Access Control](https://docs.openzeppelin.com/contracts/5.x/access-control)\n\n[Accounts ‚Üí](https://docs.openzeppelin.com/contracts/5.x/accounts)","metadata":{"og:image":"https://docs.openzeppelin.com/_/images/social.png","title":"Account Abstraction - OpenZeppelin Docs","language":"en","twitter:card":"summary","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","ogImage":"https://docs.openzeppelin.com/_/images/social.png","viewport":"width=device-width, initial-scale=1.0","og:title":"Account Abstraction - OpenZeppelin Docs","ogTitle":"Account Abstraction - OpenZeppelin Docs","scrapeId":"8bdd7593-ece4-4b4e-ae23-6e3076e5e566","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/account-abstraction","url":"https://docs.openzeppelin.com/contracts/5.x/account-abstraction","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# Access Control\n\nAccess control‚Äîthat is, \"who is allowed to do this thing\"‚Äîis incredibly important in the world of smart contracts. The access control of your contract may govern who can mint tokens, vote on proposals, freeze transfers, and many other things. It is therefore **critical** to understand how you implement it, lest someone else [steals your whole system](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7).\n\n## Ownership and `Ownable`\n\nThe most common and basic form of access control is the concept of _ownership_: there‚Äôs an account that is the `owner` of a contract and can do administrative tasks on it. This approach is perfectly reasonable for contracts that have a single administrative user.\n\nOpenZeppelin Contracts provides [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable) for implementing ownership in your contracts.\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyContract is Ownable {\n    constructor(address initialOwner) Ownable(initialOwner) {}\n\n    function normalThing() public {\n        // anyone can call this normalThing()\n    }\n\n    function specialThing() public onlyOwner {\n        // only the owner can call specialThing()!\n    }\n}\n```\n\nAt deployment, the [`owner`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable-owner--) of an `Ownable` contract is set to the provided `initialOwner` parameter.\n\nOwnable also lets you:\n\n- [`transferOwnership`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable-transferOwnership-address-) from the owner account to a new one, and\n\n- [`renounceOwnership`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable-renounceOwnership--) for the owner to relinquish this administrative privilege, a common pattern after an initial stage with centralized administration is over.\n\n\n|     |     |\n| --- | --- |\n|  | Removing the owner altogether will mean that administrative tasks that are protected by `onlyOwner` will no longer be callable! |\n\nOwnable is a simple and effective way to implement access control, but you should be mindful of the dangers associated with transferring the ownership to an incorrect account that can‚Äôt interact with this contract anymore. An alternative to this problem is using [`Ownable2Step`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable2Step); a variant of Ownable that requires the new owner to explicitly accept the ownership transfer by calling [`acceptOwnership`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable2Step-acceptOwnership--).\n\nNote that **a contract can also be the owner of another one**! This opens the door to using, for example, a [Gnosis Safe](https://safe.global/), an [Aragon DAO](https://aragon.org/), or a totally custom contract that _you_ create.\n\nIn this way, you can use _composability_ to add additional layers of access control complexity to your contracts. Instead of having a single regular Ethereum account (Externally Owned Account, or EOA) as the owner, you could use a 2-of-3 multisig run by your project leads, for example. Prominent projects in the space, such as [MakerDAO](https://makerdao.com/), use systems similar to this one.\n\n## Role-Based Access Control\n\nWhile the simplicity of _ownership_ can be useful for simple systems or quick prototyping, different levels of authorization are often needed. You may want for an account to have permission to ban users from a system, but not create new tokens. [_Role-Based Access Control (RBAC)_](https://en.wikipedia.org/wiki/Role-based_access_control) offers flexibility in this regard.\n\nIn essence, we will be defining multiple _roles_, each allowed to perform different sets of actions. An account may have, for example, 'moderator', 'minter' or 'admin' roles, which you will then check for instead of simply using `onlyOwner`. This check can be enforced through the `onlyRole` modifier. Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.\n\nMost software uses access control systems that are role-based: some users are regular users, some may be supervisors or managers, and a few will often have administrative privileges.\n\n### Using `AccessControl`\n\nOpenZeppelin Contracts provides [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) for implementing role-based access control. Its usage is straightforward: for each role that you want to define,\nyou will create a new _role identifier_ that is used to grant, revoke, and check if an account has that role.\n\nHere‚Äôs a simple example of using `AccessControl` in an [ERC-20 token](https://docs.openzeppelin.com/contracts/5.x/erc20) to define a 'minter' role, which allows accounts that have it create new tokens:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract AccessControlERC20MintBase is ERC20, AccessControl {\n    // Create a new role identifier for the minter role\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n    error CallerNotMinter(address caller);\n\n    constructor(address minter) ERC20(\"MyToken\", \"TKN\") {\n        // Grant the minter role to a specified account\n        _grantRole(MINTER_ROLE, minter);\n    }\n\n    function mint(address to, uint256 amount) public {\n        // Check that the calling account has the minter role\n        if (!hasRole(MINTER_ROLE, msg.sender)) {\n            revert CallerNotMinter(msg.sender);\n        }\n        _mint(to, amount);\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Make sure you fully understand how [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) works before using it on your system, or copy-pasting the examples from this guide. |\n\nWhile clear and explicit, this isn‚Äôt anything we wouldn‚Äôt have been able to achieve with `Ownable`. Indeed, where `AccessControl` shines is in scenarios where granular permissions are required, which can be implemented by defining _multiple_ roles.\n\nLet‚Äôs augment our ERC-20 token example by also defining a 'burner' role, which lets accounts destroy tokens, and by using the `onlyRole` modifier:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract AccessControlERC20Mint is ERC20, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor(address minter, address burner) ERC20(\"MyToken\", \"TKN\") {\n        _grantRole(MINTER_ROLE, minter);\n        _grantRole(BURNER_ROLE, burner);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n}\n```\n\nSo clean! By splitting concerns this way, more granular levels of permission may be implemented than were possible with the simpler _ownership_ approach to access control. Limiting what each component of a system is able to do is known as the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), and is a good security practice. Note that each account may still have more than one role, if so desired.\n\n### Granting and Revoking Roles\n\nThe ERC-20 token example above uses `_grantRole`, an `internal` function that is useful when programmatically assigning roles (such as during construction). But what if we later want to grant the 'minter' role to additional accounts?\n\nBy default, **accounts with a role cannot grant it or revoke it from other accounts**: all having a role does is making the `hasRole` check pass. To grant and revoke roles dynamically, you will need help from the _role‚Äôs admin_.\n\nEvery role has an associated admin role, which grants permission to call the `grantRole` and `revokeRole` functions. A role can be granted or revoked by using these if the calling account has the corresponding admin role. Multiple roles may have the same admin role to make management easier. A role‚Äôs admin can even be the same role itself, which would cause accounts with that role to be able to also grant and revoke it.\n\nThis mechanism can be used to create complex permissioning structures resembling organizational charts, but it also provides an easy way to manage simpler applications. `AccessControl` includes a special role, called `DEFAULT_ADMIN_ROLE`, which acts as the **default admin role for all roles**. An account with this role will be able to manage any other role, unless `_setRoleAdmin` is used to select a new admin role.\n\nSince it is the admin for all roles by default, and in fact it is also its own admin, this role carries significant risk. To mitigate this risk we provide [`AccessControlDefaultAdminRules`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControlDefaultAdminRules), a recommended extension of `AccessControl` that adds a number of enforced security measures for this role: the admin is restricted to a single account, with a 2-step transfer procedure with a delay in between steps.\n\nLet‚Äôs take a look at the ERC-20 token example, this time taking advantage of the default admin role:\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract AccessControlERC20MintMissing is ERC20, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n    constructor() ERC20(\"MyToken\", \"TKN\") {\n        // Grant the contract deployer the default admin role: it will be able\n        // to grant and revoke any roles\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyRole(BURNER_ROLE) {\n        _burn(from, amount);\n    }\n}\n```\n\nNote that, unlike the previous examples, no accounts are granted the 'minter' or 'burner' roles. However, because those roles' admin role is the default admin role, and _that_ role was granted to `msg.sender`, that same account can call `grantRole` to give minting or burning permission, and `revokeRole` to remove it.\n\nDynamic role allocation is often a desirable property, for example in systems where trust in a participant may vary over time. It can also be used to support use cases such as [KYC](https://en.wikipedia.org/wiki/Know_your_customer), where the list of role-bearers may not be known up-front, or may be prohibitively expensive to include in a single transaction.\n\n### Querying Privileged Accounts\n\nBecause accounts might [grant and revoke roles](https://docs.openzeppelin.com/contracts/5.x/access-control#granting-and-revoking) dynamically, it is not always possible to determine which accounts hold a particular role. This is important as it allows proving certain properties about a system, such as that an administrative account is a multisig or a DAO, or that a certain role has been removed from all users, effectively disabling any associated functionality.\n\nUnder the hood, `AccessControl` uses `EnumerableSet`, a more powerful variant of Solidity‚Äôs `mapping` type, which allows for key enumeration. `getRoleMemberCount` can be used to retrieve the number of accounts that have a particular role, and `getRoleMember` can then be called to get the address of each of these accounts.\n\n```javascript hljs\nconst minterCount = await myToken.getRoleMemberCount(MINTER_ROLE);\n\nconst members = [];\nfor (let i = 0; i < minterCount; ++i) {\n    members.push(await myToken.getRoleMember(MINTER_ROLE, i));\n}\n```\n\n## Delayed operation\n\nAccess control is essential to prevent unauthorized access to critical functions. These functions may be used to mint tokens, freeze transfers or perform an upgrade that completely changes the smart contract logic. While [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable) and [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) can prevent unauthorized access, they do not address the issue of a misbehaving administrator attacking their own system to the prejudice of their users.\n\nThis is the issue the [`TimelockController`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController) is addressing.\n\nThe [`TimelockController`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController) is a proxy that is governed by proposers and executors. When set as the owner/admin/controller of a smart contract, it ensures that whichever maintenance operation is ordered by the proposers is subject to a delay. This delay protects the users of the smart contract by giving them time to review the maintenance operation and exit the system if they consider it is in their best interest to do so.\n\n### Using `TimelockController`\n\nBy default, the address that deployed the [`TimelockController`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController) gets administration privileges over the timelock. This role grants the right to assign proposers, executors, and other administrators.\n\nThe first step in configuring the [`TimelockController`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController) is to assign at least one proposer and one executor. These can be assigned during construction or later by anyone with the administrator role. These roles are not exclusive, meaning an account can have both roles.\n\nRoles are managed using the [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) interface and the `bytes32` values for each role are accessible through the `ADMIN_ROLE`, `PROPOSER_ROLE` and `EXECUTOR_ROLE` constants.\n\nThere is an additional feature built on top of `AccessControl`: giving the executor role to `address(0)` opens access to anyone to execute a proposal once the timelock has expired. This feature, while useful, should be used with caution.\n\nAt this point, with both a proposer and an executor assigned, the timelock can perform operations.\n\nAn optional next step is for the deployer to renounce its administrative privileges and leave the timelock self-administered. If the deployer decides to do so, all further maintenance, including assigning new proposers/schedulers or changing the timelock duration will have to follow the timelock workflow. This links the governance of the timelock to the governance of contracts attached to the timelock, and enforce a delay on timelock maintenance operations.\n\n|     |     |\n| --- | --- |\n|  | If the deployer renounces administrative rights in favour of timelock itself, assigning new proposers or executors will require a timelocked operation. This means that if the accounts in charge of any of these two roles become unavailable, then the entire contract (and any contract it controls) becomes locked indefinitely. |\n\nWith both the proposer and executor roles assigned and the timelock in charge of its own administration, you can now transfer the ownership/control of any contract to the timelock.\n\n|     |     |\n| --- | --- |\n|  | A recommended configuration is to grant both roles to a secure governance contract such as a DAO or a multisig, and to additionally grant the executor role to a few EOAs held by people in charge of helping with the maintenance operations. These wallets cannot take over control of the timelock but they can help smoothen the workflow. |\n\n### Minimum delay\n\nOperations executed by the [`TimelockController`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController) are not subject to a fixed delay but rather a minimum delay. Some major updates might call for a longer delay. For example, if a delay of just a few days might be sufficient for users to audit a minting operation, it makes sense to use a delay of a few weeks, or even a few months, when scheduling a smart contract upgrade.\n\nThe minimum delay (accessible through the [`getMinDelay`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController-getMinDelay--) method) can be updated by calling the [`updateDelay`](https://docs.openzeppelin.com/contracts/5.x/api/governance#TimelockController-updateDelay-uint256-) function. Bear in mind that access to this function is only accessible by the timelock itself, meaning this maintenance operation has to go through the timelock itself.\n\n## Access Management\n\nFor a system of contracts, better integrated role management can be achieved with an [`AccessManager`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager) instance. Instead of managing each contract‚Äôs permission separately, AccessManager stores all the permissions in a single contract, making your protocol easier to audit and maintain.\n\nAlthough [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) offers a more dynamic solution for adding permissions to your contracts than Ownable, decentralized protocols tend to become more complex after integrating new contract instances and requires you to keep track of permissions separately in each contract. This increases the complexity of permissions management and monitoring across the system.\n\n![Access Control multiple](https://docs.openzeppelin.com/contracts/5.x/_images/access-control-multiple.svg)\n\nProtocols managing permissions in production systems often require more integrated alternatives to fragmented permissions through multiple `AccessControl` instances.\n\n![AccessManager](https://docs.openzeppelin.com/contracts/5.x/_images/access-manager.svg)\n\nThe AccessManager is designed around the concept of role and target functions:\n\n- Roles are granted to accounts (addresses) following a many-to-many approach for flexibility. This means that each user can have one or multiple roles and multiple users can have the same role.\n\n- Access to a restricted target function is limited to one role. A target function is defined by one [function selector](https://docs.soliditylang.org/en/v0.8.20/abi-spec.html#function-selector) on one contract (called target).\n\n\nFor a call to be authorized, the caller must bear the role that is assigned to the current target function (contract address + function selector).\n\n![AccessManager functions](https://docs.openzeppelin.com/contracts/5.x/_images/access-manager-functions.svg)\n\n### Using `AccessManager`\n\nOpenZeppelin Contracts provides [`AccessManager`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager) for managing roles across any number of contracts. The `AccessManager` itself is a contract that can be deployed and used out of the box. It sets an initial admin in the constructor who will be allowed to perform management operations.\n\nIn order to restrict access to some functions of your contract, you should inherit from the [`AccessManaged`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManaged) contract provided along with the manager. This provides the `restricted` modifier that can be used to protect any externally facing function. Note that you will have to specify the address of the AccessManager instance ( [`initialAuthority`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManaged-constructor-address-)) in the constructor so the `restricted` modifier knows which manager to use for checking permissions.\n\nHere‚Äôs a simple example of an [ERC-20 token](https://docs.openzeppelin.com/contracts/5.x/tokens#ERC20) that defines a `mint` function that is restricted by an [`AccessManager`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager):\n\n```solidity hljs\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessManaged} from \"@openzeppelin/contracts/access/manager/AccessManaged.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract AccessManagedERC20Mint is ERC20, AccessManaged {\n    constructor(address manager) ERC20(\"MyToken\", \"TKN\") AccessManaged(manager) {}\n\n    // Minting is restricted according to the manager rules for this function.\n    // The function is identified by its selector: 0x40c10f19.\n    // Calculated with bytes4(keccak256('mint(address,uint256)'))\n    function mint(address to, uint256 amount) public restricted {\n        _mint(to, amount);\n    }\n}\n```\n\n|     |     |\n| --- | --- |\n|  | Make sure you fully understand how [`AccessManager`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager) works before using it or copy-pasting the examples from this guide. |\n\nOnce the managed contract has been deployed, it is now under the manager‚Äôs control. The initial admin can then assign the minter role to an address and also allow the role to call the `mint` function. For example, this is demonstrated in the following Javascript code using Ethers.js:\n\n```javascript hljs\n// const target = ...;\n// const user = ...;\nconst MINTER = 42n; // Roles are uint64 (0 is reserved for the ADMIN_ROLE)\n\n// Grant the minter role with no execution delay\nawait manager.grantRole(MINTER, user, 0);\n\n// Allow the minter role to call the function selector\n// corresponding to the mint function\nawait manager.setTargetFunctionRole(\n    target,\n    ['0x40c10f19'], // bytes4(keccak256('mint(address,uint256)'))\n    MINTER\n);\n```\n\nEven though each role has its own list of function permissions, each role member ( `address`) has an execution delay that will dictate how long the account should wait to execute a function that requires its role. Delayed operations must have the [`schedule`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-schedule-address-bytes-uint48-) function called on them first in the AccessManager before they can be executed, either by calling to the target function or using the AccessManager‚Äôs [`execute`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-execute-address-bytes-) function.\n\nAdditionally, roles can have a granting delay that prevents adding members immediately. The AccessManager admins can set this grant delay as follows:\n\n```javascript hljs\nconst HOUR = 60 * 60;\n\nconst GRANT_DELAY = 24 * HOUR;\nconst EXECUTION_DELAY = 5 * HOUR;\nconst ACCOUNT = \"0x...\";\n\nawait manager.connect(initialAdmin).setGrantDelay(MINTER, GRANT_DELAY);\n\n// The role will go into effect after the GRANT_DELAY passes\nawait manager.connect(initialAdmin).grantRole(MINTER, ACCOUNT, EXECUTION_DELAY);\n```\n\nNote that roles do not define a name. As opposed to the [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl) case, roles are identified as numeric values instead of being hardcoded in the contract as `bytes32` values. It is still possible to allow for tooling discovery (e.g. for role exploration) using role labeling with the [`labelRole`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-labelRole-uint64-string-) function.\n\n```javascript hljs\nawait manager.labelRole(MINTER, \"MINTER\");\n```\n\nGiven the admins of the `AccessManaged` can modify all of its permissions, it‚Äôs recommended to keep only a single admin address secured under a multisig or governance layer. To achieve this, it is possible for the initial admin to set up all the required permissions, targets, and functions, assign a new admin, and finally renounce its admin role.\n\nFor improved incident response coordination, the manager includes a mode where administrators can completely close a target contract. When closed, all calls to restricted target functions in a target contract will revert.\n\nClosing and opening contracts don‚Äôt alter any of their settings, neither permissions nor delays. Particularly, the roles required for calling specific target functions are not modified.\n\nThis mode is useful for incident response operations that require temporarily shutting down a contract in order to evaluate emergencies and reconfigure permissions.\n\n```javascript hljs\nconst target = await myToken.getAddress();\n\n// Token's `restricted` functions closed\nawait manager.setTargetClosed(target, true);\n\n// Token's `restricted` functions open\nawait manager.setTargetClosed(target, false);\n```\n\n|     |     |\n| --- | --- |\n|  | Even if an `AccessManager` defines permissions for a target function, these won‚Äôt be applied if the managed contract instance is not using the [`restricted`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManaged-restricted--) modifier for that function, or if its manager is a different one. |\n\n### Role Admins and Guardians\n\nAn important aspect of the AccessControl contract is that roles aren‚Äôt granted nor revoked by role members. Instead, it relies on the concept of a role admin for granting and revoking.\n\nIn the case of the `AccessManager`, the same rule applies and only the role‚Äôs admins are able to call [grant](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-grantRole-uint64-address-uint32-) and [revoke](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-revokeRole-uint64-address-) functions. Note that calling these functions will be subject to the execution delay that the executing role admin has.\n\nAdditionally, the `AccessManager` stores a _guardian_ as an extra protection for each role. This guardian has the ability to cancel operations that have been scheduled by any role member with an execution delay. Consider that a role will have its initial admin and guardian default to the `ADMIN_ROLE` ( `0`).\n\n|     |     |\n| --- | --- |\n|  | Be careful with the members of `ADMIN_ROLE`, since it acts as the default admin and guardian for every role. A misbehaved guardian can cancel operations at will, affecting the AccessManager‚Äôs operation. |\n\n### Manager configuration\n\nThe `AccessManager` provides a built-in interface for configuring permission settings that can be accessed by its `ADMIN_ROLE` members.\n\nThis configuration interface includes the following functions:\n\n- Add a label to a role using the [`labelRole`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-labelRole-uint64-string-) function.\n\n- Assign the admin and guardian of a role with [`setRoleAdmin`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setRoleAdmin-uint64-uint64-) and [`setRoleGuardian`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setRoleGuardian-uint64-uint64-).\n\n- Set each role‚Äôs grant delay via [`setGrantDelay`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setGrantDelay-uint64-uint32-).\n\n\nAs an admin, some actions will require a delay. Similar to each member‚Äôs execution delay, some admin operations require waiting for execution and should follow the [`schedule`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-schedule-address-bytes-uint48-) and [`execute`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-execute-address-bytes-) workflow.\n\nMore specifically, these delayed functions are those for configuring the settings of a specific target contract. The delay applied to these functions can be adjusted by the manager admins with [`setTargetAdminDelay`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setTargetAdminDelay-address-uint32-).\n\nThe delayed admin actions are:\n\n- Updating an `AccessManaged` contract [authority](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManaged-authority--) using [`updateAuthority`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-updateAuthority-address-address-).\n\n- Closing or opening a target via [`setTargetClosed`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setTargetClosed-address-bool-).\n\n- Changing permissions of whether a role can call a target function with [`setTargetFunctionRole`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-setTargetFunctionRole-address-bytes4---uint64-).\n\n\n### Using with Ownable\n\nContracts already inheriting from [`Ownable`](https://docs.openzeppelin.com/contracts/5.x/api/access#Ownable) can migrate to AccessManager by transferring ownership to the manager. After that, all calls to functions with the `onlyOwner` modifier should be called through the manager‚Äôs [`execute`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-execute-address-bytes-) function, even if the caller doesn‚Äôt require a delay.\n\n```javascript hljs\nawait ownable.connect(owner).transferOwnership(accessManager);\n```\n\n### Using with AccessControl\n\nFor systems already using [`AccessControl`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessControl), the `DEFAULT_ADMIN_ROLE` can be granted to the `AccessManager` after revoking every other role. Subsequent calls should be made through the manager‚Äôs [`execute`](https://docs.openzeppelin.com/contracts/5.x/api/access#AccessManager-execute-address-bytes-) method, similar to the Ownable case.\n\n```javascript hljs\n// Revoke old roles\nawait accessControl.connect(admin).revokeRole(MINTER_ROLE, account);\n\n// Grant the admin role to the access manager\nawait accessControl.connect(admin).grantRole(DEFAULT_ADMIN_ROLE, accessManager);\n\nawait accessControl.connect(admin).renounceRole(DEFAULT_ADMIN_ROLE, admin);\n```\n\n[‚Üê Backwards Compatibility](https://docs.openzeppelin.com/contracts/5.x/backwards-compatibility)\n\n[Account Abstraction ‚Üí](https://docs.openzeppelin.com/contracts/5.x/account-abstraction)","metadata":{"ogTitle":"Access Control - OpenZeppelin Docs","twitter:card":"summary","og:title":"Access Control - OpenZeppelin Docs","viewport":"width=device-width, initial-scale=1.0","language":"en","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","og:image":"https://docs.openzeppelin.com/_/images/social.png","title":"Access Control - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","scrapeId":"c16a42ff-4103-48db-acf9-773102fcc722","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/access-control","url":"https://docs.openzeppelin.com/contracts/5.x/access-control","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."},{"markdown":"# ERC-20\n\nAn ERC-20 token contract keeps track of [_fungible_ tokens](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens): any one token is exactly equal to any other token; no tokens have special rights or behavior associated with them. This makes ERC-20 tokens useful for things like a **medium of exchange currency**, **voting rights**, **staking**, and more.\n\nOpenZeppelin Contracts provides many ERC20-related contracts. On the [`API reference`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20) you‚Äôll find detailed information on their properties and usage.\n\n## Constructing an ERC-20 Token Contract\n\nUsing Contracts, we can easily create our own ERC-20 token contract, which will be used to track _Gold_ (GLD), an internal currency in a hypothetical game.\n\nHere‚Äôs what our GLD token might look like.\n\n```solidity hljs\n// contracts/GLDToken.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract GLDToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"Gold\", \"GLD\") {\n        _mint(msg.sender, initialSupply);\n    }\n}\n```\n\nOur contracts are often used via [inheritance](https://solidity.readthedocs.io/en/latest/contracts.html#inheritance), and here we‚Äôre reusing [`ERC20`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#erc20) for both the basic standard implementation and the [`name`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-name--), [`symbol`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-symbol--), and [`decimals`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-decimals--) optional extensions. Additionally, we‚Äôre creating an `initialSupply` of tokens, which will be assigned to the address that deploys the contract.\n\n|     |     |\n| --- | --- |\n|  | For a more complete discussion of ERC-20 supply mechanisms, see [Creating ERC-20 Supply](https://docs.openzeppelin.com/contracts/5.x/erc20-supply). |\n\nThat‚Äôs it! Once deployed, we will be able to query the deployer‚Äôs balance:\n\n```javascript hljs\n> GLDToken.balanceOf(deployerAddress)\n1000000000000000000000\n```\n\nWe can also [transfer](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#IERC20-transfer-address-uint256-) these tokens to other accounts:\n\n```javascript hljs\n> GLDToken.transfer(otherAddress, 300000000000000000000)\n> GLDToken.balanceOf(otherAddress)\n300000000000000000000\n> GLDToken.balanceOf(deployerAddress)\n700000000000000000000\n```\n\n## A Note on `decimals`\n\nOften, you‚Äôll want to be able to divide your tokens into arbitrary amounts: say, if you own `5 GLD`, you may want to send `1.5 GLD` to a friend, and keep `3.5 GLD` to yourself. Unfortunately, Solidity and the EVM do not support this behavior: only integer (whole) numbers can be used, which poses an issue. You may send `1` or `2` tokens, but not `1.5`.\n\nTo work around this, [`ERC20`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20) provides a [`decimals`](https://docs.openzeppelin.com/contracts/5.x/api/token/ERC20#ERC20-decimals--) field, which is used to specify how many decimal places a token has. To be able to transfer `1.5 GLD`, `decimals` must be at least `1`, since that number has a single decimal place.\n\nHow can this be achieved? It‚Äôs actually very simple: a token contract can use larger integer values, so that a balance of `50` will represent `5 GLD`, a transfer of `15` will correspond to `1.5 GLD` being sent, and so on.\n\nIt is important to understand that `decimals` is _only used for display purposes_. All arithmetic inside the contract is still performed on integers, and it is the different user interfaces (wallets, exchanges, etc.) that must adjust the displayed values according to `decimals`. The total token supply and balance of each account are not specified in `GLD`: you need to divide by `10 ** decimals` to get the actual `GLD` amount.\n\nYou‚Äôll probably want to use a `decimals` value of `18`, just like Ether and most ERC-20 token contracts in use, unless you have a very special reason not to. When minting tokens or transferring them around, you will be actually sending the number `num GLD * (10 ** decimals)`.\n\n|     |     |\n| --- | --- |\n|  | By default, `ERC20` uses a value of `18` for `decimals`. To use a different value, you will need to override the `decimals()` function in your contract. |\n\n```solidity hljs\nfunction decimals() public view virtual override returns (uint8) {\n  return 16;\n}\n```\n\nSo if you want to send `5` tokens using a token contract with 18 decimals, the method to call will actually be:\n\n```solidity hljs\ntransfer(recipient, 5 * (10 ** 18));\n```\n\n[‚Üê Tokens](https://docs.openzeppelin.com/contracts/5.x/tokens)\n\n[Creating Supply ‚Üí](https://docs.openzeppelin.com/contracts/5.x/erc20-supply)","metadata":{"og:image":"https://docs.openzeppelin.com/_/images/social.png","language":"en","title":"ERC-20 - OpenZeppelin Docs","og:title":"ERC-20 - OpenZeppelin Docs","ogImage":"https://docs.openzeppelin.com/_/images/social.png","viewport":"width=device-width, initial-scale=1.0","twitter:card":"summary","ogTitle":"ERC-20 - OpenZeppelin Docs","favicon":"https://docs.openzeppelin.com/_/images/favicon.ico","scrapeId":"04890405-137b-4a1e-9bb9-3820bfd2581d","sourceURL":"https://docs.openzeppelin.com/contracts/5.x/erc20","url":"https://docs.openzeppelin.com/contracts/5.x/erc20","statusCode":200,"contentType":"text/html; charset=UTF-8","proxyUsed":"basic","creditsUsed":1},"warning":"This scrape job was throttled at your current concurrency limit. If you'd like to scrape faster, you can upgrade your plan."}]}